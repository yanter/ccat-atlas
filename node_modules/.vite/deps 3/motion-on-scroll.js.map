{
  "version": 3,
  "sources": ["../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/animations.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/constants.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/easing.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/attributes.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/position-calculator.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/elements.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/keyframes.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/observer.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/utils.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/helpers/scroll-handler.ts", "../../.pnpm/motion-on-scroll@1.0.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/motion-on-scroll/src/index.ts"],
  "sourcesContent": ["// ===================================================================\n// ANIMATION CONTROL SYSTEM\n// ===================================================================\n// This module manages animation creation, playback, and state for\n// Motion-on-Scroll elements. It handles both built-in animations\n// and custom user-registered animations.\n\nimport { animate, type AnimationPlaybackControls, type KeyframeOptions } from \"motion\";\n\nimport { DEFAULT_OPTIONS } from \"./constants.js\";\nimport { resolveEasing } from \"./easing.js\";\nimport { findPreparedElement } from \"./elements.js\";\nimport { getKeyframesWithDistance, resolveKeyframes } from \"./keyframes.js\";\nimport type { ElementOptions, MosElement } from \"./types.js\";\n\n// ===================================================================\n// TYPES AND INTERFACES\n// ===================================================================\n\n/**\n * Factory function type for creating custom animations\n * Takes an element and options, returns Motion's animation controls\n */\nexport type AnimationFactory = (el: HTMLElement, opts: ElementOptions) => AnimationPlaybackControls;\n\n// ===================================================================\n// MODULE STATE\n// ===================================================================\n\n/**\n * Maps elements to their currently running animation controls\n * Used to track which elements are actively animating\n */\nconst activeAnimations = new WeakMap<HTMLElement, AnimationPlaybackControls>();\n\n/**\n * Registry of custom animations registered by users\n * Maps animation names to their factory functions\n */\nconst customAnimationRegistry: Record<string, AnimationFactory> = {};\n\n// ===================================================================\n// CUSTOM ANIMATION REGISTRATION\n// ===================================================================\n\n/**\n * Registers a custom animation that can be used by name in data-mos attributes\n * The factory function receives the element and options, and must return Motion's AnimationPlaybackControls\n *\n * @param name - Unique name for the animation (used in data-mos=\"name\")\n * @param factory - Function that creates and returns animation controls\n *\n * @example\n * ```typescript\n * registerAnimation('customSlide', (element, options) => {\n *   return animate(element, { x: [100, 0] }, { duration: options.duration });\n * });\n * ```\n *\n * @throws Error if name is empty or invalid\n */\nexport function registerAnimation(name: string, factory: AnimationFactory): void {\n  if (!name || name.trim() === \"\") {\n    throw new Error(\"Custom animation name must be non-empty\");\n  }\n  customAnimationRegistry[name] = factory;\n}\n\n// ===================================================================\n// ANIMATION CONTROL MANAGEMENT\n// ===================================================================\n\n/**\n * Ensures animation controls exist for an element, creating them only once\n * Subsequent calls return the existing controls for performance\n *\n * @param element - The DOM element to ensure animation for\n * @param options - Animation configuration options\n * @returns Animation controls or null if creation failed\n */\nfunction ensureAnimationControls(\n  element: HTMLElement,\n  options: ElementOptions,\n): AnimationPlaybackControls | null {\n  const mosElement = findPreparedElement(element);\n  if (!mosElement) return null;\n\n  // Return existing controls if available\n  if (mosElement.controls) {\n    return mosElement.controls;\n  }\n\n  // Create new animation controls\n  const controls = createAnimationControls(element, options);\n  if (!controls) return null;\n\n  // Store controls in unified element\n  mosElement.controls = controls;\n\n  return controls;\n}\n\n// ===================================================================\n// ANIMATION STATE SETTERS\n// ===================================================================\n\n/**\n * Sets an element to its initial animation state without playing the animation\n * Creates animation controls but preserves natural position for accurate scroll calculations\n * CSS handles initial visibility (opacity: 0, visibility: hidden, etc.)\n *\n * @param mosElement - The MOS element data containing element, options, and state\n */\nexport function setInitialState(mosElement: MosElement): void {\n  const { element, options } = mosElement;\n\n  // Skip if element is currently animating\n  if (activeAnimations.has(element)) return;\n\n  const controls = ensureAnimationControls(element, options);\n  if (!controls) return;\n\n  // Pause controls without setting time to preserve natural element position\n  // This is crucial for accurate scroll position calculations\n  controls.pause();\n\n  // Update element state\n  mosElement.animated = false;\n  mosElement.isReversing = false;\n}\n\n/**\n * Sets up a single completion handler for animation controls\n * Uses element state to determine whether to handle forward or reverse completion\n *\n * @param element - The DOM element being animated\n * @param controls - The animation controls to set up handler for\n * @param options - Animation configuration options\n */\nfunction setupAnimationCompletionHandler(\n  element: HTMLElement,\n  controls: AnimationPlaybackControls,\n  options: ElementOptions,\n): void {\n  controls.finished\n    .then(() => {\n      const mosElement = findPreparedElement(element);\n      if (!mosElement) return;\n\n      if (mosElement.isReversing) {\n        handleReverseAnimationCompletion(element, controls, mosElement);\n      } else {\n        handleForwardAnimationCompletion(element, controls, options);\n      }\n    })\n    .catch(() => {\n      handleAnimationInterruption(element);\n    });\n}\n\n/**\n * Handles completion of a reverse animation\n * Resets element to initial state and calls completion callback\n */\nfunction handleReverseAnimationCompletion(\n  element: HTMLElement,\n  controls: AnimationPlaybackControls,\n  mosElement: MosElement,\n): void {\n  // Reset animation to initial state\n  controls.time = 0;\n  controls.pause();\n  activeAnimations.delete(element);\n  element.classList.remove(\"mos-animate\");\n\n  // Update state\n  mosElement.isReversing = false;\n  mosElement.animated = false;\n}\n\n/**\n * Handles completion of a forward animation\n * Cleans up active animation tracking\n */\nfunction handleForwardAnimationCompletion(\n  element: HTMLElement,\n  controls: AnimationPlaybackControls,\n  options: ElementOptions,\n): void {\n  if (options.once) {\n    // Stop animation permanently for once-only animations\n    controls.stop();\n  }\n\n  // Remove from active animations\n  activeAnimations.delete(element);\n}\n\n/**\n * Handles animation interruption (cancellation, errors, etc.)\n * Cleans up state to prevent memory leaks\n */\nfunction handleAnimationInterruption(element: HTMLElement): void {\n  const mosElement = findPreparedElement(element);\n  if (mosElement) {\n    mosElement.isReversing = false;\n  }\n}\n\n// ===================================================================\n// ANIMATION CREATION\n// ===================================================================\n\n/**\n * Creates animation controls for an element without starting playback\n * Handles both custom animations and built-in keyframe animations\n *\n * @param element - The DOM element to create animation for\n * @param options - Animation configuration options\n * @returns Animation controls or null if creation failed\n */\nfunction createAnimationControls(\n  element: HTMLElement,\n  options: ElementOptions,\n): AnimationPlaybackControls | null {\n  // Check for custom animation first\n  const customAnimation = customAnimationRegistry[options.keyframes];\n  if (customAnimation) {\n    return createCustomAnimation(element, options, customAnimation);\n  }\n\n  // Create built-in keyframe animation\n  return createKeyframeAnimation(element, options);\n}\n\n/**\n * Creates a custom animation using a registered animation factory\n * @param element - The DOM element to animate\n * @param options - Animation configuration options\n * @param factory - The custom animation factory function\n * @returns Animation controls from the custom factory\n */\nfunction createCustomAnimation(\n  element: HTMLElement,\n  options: ElementOptions,\n  factory: AnimationFactory,\n): AnimationPlaybackControls {\n  const controls = factory(element, options);\n  setupAnimationCompletionHandler(element, controls, options);\n  return controls;\n}\n\n/**\n * Creates a built-in keyframe animation using Motion's animate function\n * @param element - The DOM element to animate\n * @param options - Animation configuration options\n * @returns Animation controls from Motion\n */\nfunction createKeyframeAnimation(\n  element: HTMLElement,\n  options: ElementOptions,\n): AnimationPlaybackControls {\n  // Resolve keyframes for the animation\n  const keyframes = resolveAnimationKeyframes(options);\n\n  // Resolve easing function\n  const easing = resolveAnimationEasing(options);\n\n  // Create animation with Motion\n  const controls = animate(element, keyframes, {\n    duration: options.timeUnits === \"s\" ? options.duration : options.duration / 1000,\n    delay: options.timeUnits === \"s\" ? options.delay : options.delay / 1000,\n    ease: easing,\n    fill: \"both\",\n  } as KeyframeOptions);\n\n  // Set up completion handling\n  setupAnimationCompletionHandler(element, controls, options);\n\n  return controls;\n}\n\n/**\n * Resolves and processes keyframes for an animation\n * Applies custom distance if specified\n * @param options - Animation configuration options\n * @returns Processed keyframes ready for Motion\n */\nfunction resolveAnimationKeyframes(options: ElementOptions): any {\n  const resolvedKeyframes = resolveKeyframes(options.keyframes);\n\n  // Apply custom distance if different from default\n  if (options.distance != null && options.distance !== DEFAULT_OPTIONS.distance) {\n    return getKeyframesWithDistance(options, resolvedKeyframes);\n  }\n\n  return resolvedKeyframes;\n}\n\n/**\n * Resolves the easing function for an animation\n * Handles fallback to default easing if invalid\n * @param options - Animation configuration options\n * @returns Resolved easing function or undefined\n */\nfunction resolveAnimationEasing(options: ElementOptions): any {\n  let easing = resolveEasing(options.easing);\n\n  // Handle invalid easing with fallback\n  if (options.easing && easing === null) {\n    console.warn(\n      `[MOS] Invalid easing \"${String(options.easing)}\" – falling back to default \"${DEFAULT_OPTIONS.easing}\".`,\n    );\n    easing = resolveEasing(DEFAULT_OPTIONS.easing);\n  }\n\n  return easing === null ? undefined : easing;\n}\n\n/**\n * Sets an element to its final animation state instantly\n * Used for elements that are above the viewport on page load\n * Uses Motion's complete() method to properly set final state for smooth reversal\n *\n * @param mosElement - The MOS element data containing element, options, and state\n */\nexport function setFinalState(mosElement: MosElement): void {\n  const { element, options } = mosElement;\n\n  const controls = ensureAnimationControls(element, options);\n  if (!controls) return;\n\n  // Use Motion's complete() method to properly reach final state\n  // This ensures the animation is in the correct state for smooth reversal\n  controls.complete();\n\n  // Mark element as animated and add CSS class\n  element.classList.add(\"mos-animate\");\n\n  // Update element state\n  mosElement.animated = true;\n  mosElement.isReversing = false;\n}\n\n// ===================================================================\n// ANIMATION PLAYBACK CONTROL\n// ===================================================================\n\n/**\n * Plays the animation for an element in the forward direction\n * Creates animation controls if they don't exist, otherwise reuses existing ones\n *\n * @param mosElement - The MOS element data containing element, options, and state\n */\nexport function play(mosElement: MosElement): void {\n  const { element, options } = mosElement;\n\n  // Ensure animation controls exist\n  const controls = ensureAnimationControls(element, options);\n  if (!controls) return;\n\n  const existingAnimation = activeAnimations.get(element);\n\n  // Don't interrupt if already animating forward\n  if (existingAnimation && !mosElement.isReversing) return;\n\n  // Configure for forward playback\n  controls.speed = 1;\n  controls.play();\n\n  // Update state\n  mosElement.animated = true;\n  mosElement.isReversing = false;\n\n  // Add CSS class for styling and mark as actively animating\n  element.classList.add(\"mos-animate\");\n  activeAnimations.set(element, controls);\n}\n\n/**\n * Reverses the animation for an element (used for scroll up behavior)\n * Uses negative playback speed to smoothly reverse the animation\n *\n * @param mosElement - The MOS element data containing element, options, and state\n */\nexport function reverse(mosElement: MosElement): void {\n  if (!mosElement.controls) return;\n\n  const { element, controls } = mosElement;\n\n  // Configure for reverse playback\n  mosElement.isReversing = true;\n  controls.speed = -1;\n  controls.play();\n\n  // Mark as actively animating\n  activeAnimations.set(element, controls);\n}\n\nexport default {\n  play,\n  reverse,\n  setFinalState,\n  setInitialState,\n  registerAnimation,\n};\n", "import type { DOMKeyframesDefinition, KeyframeOptions } from \"motion\";\n\nimport type { MosOptions } from \"./types.js\";\nexport const DATA_PREFIX = \"mos\";\n\n/**\n * Default options for MOS, based on AOS defaults\n */\nexport const DEFAULT_OPTIONS: MosOptions = {\n  offset: 120,\n  duration: 400,\n  distance: 100,\n  delay: 0,\n  easing: \"ease\",\n  once: false,\n  mirror: false,\n  disable: false,\n  disableMutationObserver: false,\n  timeUnits: \"ms\",\n  startEvent: \"DOMContentLoaded\",\n  throttleDelay: 99,\n  debounceDelay: 50,\n};\n\n/**\n * Common easing keywords mapped to their cubic-bezier equivalents (ported from AOS),\n * in addition to the standard supported functions from motion\n */\nexport const EASINGS: Record<string, KeyframeOptions[\"ease\"]> = {\n  linear: \"linear\",\n  ease: undefined, // this is how motion represents \"ease\"\n  \"ease-in\": \"easeIn\",\n  \"ease-out\": \"easeOut\",\n  \"ease-in-out\": \"easeInOut\",\n  \"circ-in\": \"circIn\",\n  \"circ-out\": \"circOut\",\n  \"circ-in-out\": \"circInOut\",\n  \"back-in\": \"backIn\",\n  \"back-out\": \"backOut\",\n  \"back-in-out\": \"backInOut\",\n  anticipate: \"anticipate\",\n\n  \"ease-in-back\": [0.6, -0.28, 0.735, 0.045],\n  \"ease-out-back\": [0.175, 0.885, 0.32, 1.275],\n  \"ease-in-out-back\": [0.68, -0.55, 0.265, 1.55],\n\n  \"ease-in-sine\": [0.47, 0, 0.745, 0.715],\n  \"ease-out-sine\": [0.39, 0.575, 0.565, 1],\n  \"ease-in-out-sine\": [0.445, 0.05, 0.55, 0.95],\n\n  \"ease-in-quad\": [0.55, 0.085, 0.68, 0.53],\n  \"ease-out-quad\": [0.25, 0.46, 0.45, 0.94],\n  \"ease-in-out-quad\": [0.455, 0.03, 0.515, 0.955],\n\n  \"ease-in-cubic\": [0.55, 0.085, 0.68, 0.53],\n  \"ease-out-cubic\": [0.25, 0.46, 0.45, 0.94],\n  \"ease-in-out-cubic\": [0.455, 0.03, 0.515, 0.955],\n\n  \"ease-in-quart\": [0.55, 0.085, 0.68, 0.53],\n  \"ease-out-quart\": [0.25, 0.46, 0.45, 0.94],\n  \"ease-in-out-quart\": [0.455, 0.03, 0.515, 0.955],\n} as const;\nexport type EasingKeyword = keyof typeof EASINGS;\n\n// Built-in animation presets\nexport const KEYFRAMES_PRESETS: Record<string, DOMKeyframesDefinition> = {\n  // Fades\n  fade: { opacity: [0, 1] },\n  \"fade-up\": { opacity: [0, 1], translateY: [100, 0] },\n  \"fade-down\": { opacity: [0, 1], translateY: [-100, 0] },\n  \"fade-left\": { opacity: [0, 1], translateX: [100, 0] },\n  \"fade-right\": { opacity: [0, 1], translateX: [-100, 0] },\n  \"fade-up-right\": { opacity: [0, 1], translateY: [100, 0], translateX: [-100, 0] },\n  \"fade-up-left\": { opacity: [0, 1], translateY: [100, 0], translateX: [100, 0] },\n  \"fade-down-right\": { opacity: [0, 1], translateY: [-100, 0], translateX: [-100, 0] },\n  \"fade-down-left\": { opacity: [0, 1], translateY: [-100, 0], translateX: [100, 0] },\n  // Flips\n  \"flip-up\": { perspective: [2500, 2500], rotateX: [-100, 0] },\n  \"flip-down\": { perspective: [2500, 2500], rotateX: [100, 0] },\n  \"flip-left\": { perspective: [2500, 2500], rotateY: [100, 0] },\n  \"flip-right\": { perspective: [2500, 2500], rotateY: [-100, 0] },\n  // Slides\n  \"slide-up\": { translateY: [100, 0] },\n  \"slide-down\": { translateY: [-100, 0] },\n  \"slide-left\": { translateX: [100, 0] },\n  \"slide-right\": { translateX: [-100, 0] },\n  // Zooms\n  \"zoom-in\": { opacity: [0, 1], scale: [0.6, 1] },\n  \"zoom-in-up\": { opacity: [0, 1], scale: [0.6, 1], translateY: [100, 0] },\n  \"zoom-in-down\": { opacity: [0, 1], scale: [0.6, 1], translateY: [-100, 0] },\n  \"zoom-in-left\": { opacity: [0, 1], scale: [0.6, 1], translateX: [100, 0] },\n  \"zoom-in-right\": { opacity: [0, 1], scale: [0.6, 1], translateX: [-100, 0] },\n  \"zoom-out\": { opacity: [0, 1], scale: [1.2, 1] },\n  \"zoom-out-up\": { opacity: [0, 1], scale: [1.2, 1], translateY: [100, 0] },\n  \"zoom-out-down\": { opacity: [0, 1], scale: [1.2, 1], translateY: [-100, 0] },\n  \"zoom-out-left\": { opacity: [0, 1], scale: [1.2, 1], translateX: [100, 0] },\n  \"zoom-out-right\": { opacity: [0, 1], scale: [1.2, 1], translateX: [-100, 0] },\n};\n", "import { type KeyframeOptions } from \"motion\";\n\nimport { EASINGS } from \"./constants.js\";\n\n/**\n * Type for custom easing definitions that can be registered\n */\nexport type EasingDefinition = KeyframeOptions[\"ease\"];\n\n/**\n * Storage for custom registered easings\n */\nconst customEasings: Record<string, EasingDefinition> = {};\n\n/**\n * Resolve a developer-supplied easing value into something Motion accepts.\n *\n * Accepts the following forms (mirrors MOS runtime):\n * 1. Custom easing name (registered via `registerEasing`) → cubic-bezier array\n * 2. Keyword (in EASINGS map)             → mapped cubic-bezier string\n * 3. `cubic-bezier(x1, y1, x2, y2)`       → number[4]\n * 4. `[x1,y1,x2,y2]` or `x1,y1,x2,y2`     → number[4]\n * 5. Otherwise                            → null\n */\nexport function resolveEasing(input: unknown): EasingDefinition | null {\n  if (input == null || typeof input !== \"string\") return undefined;\n\n  // 1. Keyword mapping (check custom easings first, then built-in)\n  if (Object.prototype.hasOwnProperty.call(customEasings, input)) return customEasings[input];\n\n  if (Object.prototype.hasOwnProperty.call(EASINGS, input))\n    return EASINGS[input as keyof typeof EASINGS];\n\n  const candidate = input.trim();\n\n  // 2. cubic-bezier() string → array\n  const cubicMatch = candidate.match(\n    /cubic-bezier\\s*\\(\\s*([0-9.]+)\\s*,\\s*([0-9.]+)\\s*,\\s*([0-9.]+)\\s*,\\s*([0-9.]+)\\s*\\)/,\n  );\n  if (cubicMatch) {\n    const nums = cubicMatch.slice(1, 5).map(Number);\n    if (nums.length === 4 && nums.every((n) => Number.isFinite(n))) {\n      return nums as [number, number, number, number];\n    }\n  }\n\n  // 3. Bare/Bracketed array\n  const arrayMatch = candidate.match(\n    /^[\\s[]*([0-9.]+)\\s*,\\s*([0-9.]+)\\s*,\\s*([0-9.]+)\\s*,\\s*([0-9.]+)[\\s\\]]*$/,\n  );\n  if (arrayMatch) {\n    const nums = arrayMatch.slice(1, 5).map(Number);\n    if (nums.length === 4 && nums.every((n) => Number.isFinite(n))) {\n      return nums as [number, number, number, number];\n    }\n  }\n\n  // 4. Invalid → null (signals caller to fallback)\n  return null;\n}\n\n/**\n * Register a custom easing function with a given name.\n *\n * Accepts Motion's easing definitions:\n * - Named strings: \"easeIn\", \"easeOut\", \"linear\", etc.\n * - Cubic bezier arrays: [0.25, 0.46, 0.45, 0.94]\n * - Step functions and other Motion easing types\n * - Cubic bezier strings: \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\"\n *\n * @param name - The name to register the easing under\n * @param definition - The easing definition (Motion-compatible or cubic-bezier string)\n *\n * @example\n * ```typescript\n * // Register a cubic bezier array\n * registerEasing(\"bouncy\", [0.68, -0.55, 0.265, 1.55]);\n *\n * // Register a cubic-bezier string (will be parsed for motion)\n * registerEasing(\"custom\", \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\");\n * ```\n */\nexport function registerEasing(name: string, definition: EasingDefinition | string): void {\n  if (!name || name.trim() === \"\") throw new Error(\"Custom easing name must be non-empty\");\n\n  // If definition is a string, try to resolve it using existing parsing logic\n  if (typeof definition === \"string\") {\n    const resolved = resolveEasing(definition);\n    if (resolved === null) {\n      throw new Error(`Invalid easing definition: \"${definition}\"`);\n    }\n    customEasings[name] = resolved;\n  } else {\n    // Direct Motion easing definition (array, function, etc.)\n    customEasings[name] = definition;\n  }\n}\n\nexport default {\n  registerEasing,\n  resolveEasing,\n};\n", "import { DATA_PREFIX, DEFAULT_OPTIONS } from \"./constants.js\";\nimport type { ElementOptions, PartialMosOptions } from \"./types.js\";\n\n/** Read a numeric attribute in pixels/ms etc. */\nfunction readNumber(el: HTMLElement, name: string): number | undefined {\n  const raw = el.dataset[name as keyof typeof el.dataset];\n  if (raw == null) return undefined;\n  const val = parseFloat(raw);\n  return Number.isFinite(val) ? val : undefined;\n}\n\nexport function resolveElementOptions(el: HTMLElement, global: PartialMosOptions): ElementOptions {\n  const keyframes = el.dataset[DATA_PREFIX as any] || \"fade\";\n\n  const opts: Partial<ElementOptions> = {\n    offset: readNumber(el, `${DATA_PREFIX}Offset`),\n    duration: readNumber(el, `${DATA_PREFIX}Duration`),\n    delay: readNumber(el, `${DATA_PREFIX}Delay`),\n    distance: readNumber(el, `${DATA_PREFIX}Distance`),\n    easing: el.dataset[`${DATA_PREFIX}Easing` as any],\n    anchor: el.dataset[`${DATA_PREFIX}Anchor` as any],\n    once: el.hasAttribute(`data-${DATA_PREFIX}-once`)\n      ? el.getAttribute(`data-${DATA_PREFIX}-once`) !== \"false\"\n      : undefined,\n    mirror: el.hasAttribute(`data-${DATA_PREFIX}-mirror`)\n      ? el.getAttribute(`data-${DATA_PREFIX}-mirror`) !== \"false\"\n      : undefined,\n    anchorPlacement: el.dataset[`${DATA_PREFIX}AnchorPlacement` as any] as any,\n  };\n\n  const merged = { ...DEFAULT_OPTIONS, ...global, ...cleanUndefined(opts) } as ElementOptions;\n\n  return { ...merged, keyframes };\n}\n\nfunction cleanUndefined<T extends Record<string, any>>(obj: T): Partial<T> {\n  const result: Partial<T> = {};\n  for (const k in obj) {\n    if (obj[k] !== undefined) result[k] = obj[k];\n  }\n  return result;\n}\n\nexport default {\n  resolveElementOptions,\n};\n", "/**\n * Position calculation utilities based on AOS approach\n * Calculates element trigger positions based on natural document position\n */\n\nimport type { ElementOptions } from \"./types.js\";\n\n/**\n * Get element's natural offset position (ignoring transforms)\n * Based on AOS offset calculation\n */\nexport function getElementOffset(el: HTMLElement): { top: number; left: number } {\n  let x = 0;\n  let y = 0;\n  let element = el;\n\n  while (element && !isNaN(element.offsetLeft) && !isNaN(element.offsetTop)) {\n    x += element.offsetLeft - (element.tagName !== \"BODY\" ? element.scrollLeft : 0);\n    y += element.offsetTop - (element.tagName !== \"BODY\" ? element.scrollTop : 0);\n    element = element.offsetParent as HTMLElement;\n  }\n\n  return {\n    top: y,\n    left: x,\n  };\n}\n\n/**\n * Calculate trigger position for element entering viewport\n */\nexport function getPositionIn(el: HTMLElement, opts: ElementOptions): number {\n  const windowHeight = window.innerHeight;\n  const triggerEl = opts.anchor ? (document.querySelector<HTMLElement>(opts.anchor) ?? el) : el;\n\n  let triggerPoint = getElementOffset(triggerEl).top - windowHeight;\n\n  // Handle anchor placement (9-grid system)\n  switch (opts.anchorPlacement) {\n    case \"top-bottom\":\n      // Default - no adjustment needed\n      break;\n    case \"center-bottom\":\n      triggerPoint += triggerEl.offsetHeight / 2;\n      break;\n    case \"bottom-bottom\":\n      triggerPoint += triggerEl.offsetHeight;\n      break;\n    case \"top-center\":\n      triggerPoint += windowHeight / 2;\n      break;\n    case \"center-center\":\n      triggerPoint += windowHeight / 2 + triggerEl.offsetHeight / 2;\n      break;\n    case \"bottom-center\":\n      triggerPoint += windowHeight / 2 + triggerEl.offsetHeight;\n      break;\n    case \"top-top\":\n      triggerPoint += windowHeight;\n      break;\n    case \"bottom-top\":\n      triggerPoint += windowHeight + triggerEl.offsetHeight;\n      break;\n    case \"center-top\":\n      triggerPoint += windowHeight + triggerEl.offsetHeight / 2;\n      break;\n  }\n\n  return triggerPoint + opts.offset;\n}\n\n/**\n * Calculate trigger position for element exiting viewport (for scroll up behavior)\n */\nexport function getPositionOut(el: HTMLElement, opts: ElementOptions): number {\n  const triggerEl = opts.anchor ? (document.querySelector<HTMLElement>(opts.anchor) ?? el) : el;\n  const elementOffsetTop = getElementOffset(triggerEl).top;\n\n  return elementOffsetTop + triggerEl.offsetHeight - opts.offset;\n}\n\n/**\n * Check if element is above current viewport (for initial state setting)\n */\nexport function isElementAboveViewport(el: HTMLElement): boolean {\n  const elementOffset = getElementOffset(el);\n  const elementBottom = elementOffset.top + el.offsetHeight;\n  return elementBottom < window.scrollY;\n}\n\nexport default {\n  getElementOffset,\n  getPositionIn,\n  getPositionOut,\n  isElementAboveViewport,\n};\n", "// ===================================================================\n// UNIFIED ELEMENT MANAGEMENT\n// ===================================================================\n// This module provides a single source of truth for all MOS elements,\n// based on the AOS prepare() pattern.\n\nimport { resolveElementOptions } from \"./attributes.js\";\nimport { getPositionIn, getPositionOut } from \"./position-calculator.js\";\nimport type { MosElement, MosOptions } from \"./types.js\";\n\n// ===================================================================\n// UNIFIED ELEMENT STORAGE (SINGLE SOURCE OF TRUTH)\n// ===================================================================\n\n/**\n * Single source of truth for all elements being tracked by MOS\n * Contains both raw elements and their prepared data (positions, options, state)\n */\nlet mosElements: MosElement[] = [];\n\n// ===================================================================\n// DOM ELEMENT DISCOVERY\n// ===================================================================\n\n/**\n * Gets all raw DOM elements, using prepared elements as cache when available\n * If elements haven't been prepared yet or need refresh, queries DOM directly\n */\nexport function getMosElements(findNewElements: boolean = false): HTMLElement[] {\n  // If we have prepared elements and don't need refresh, extract from them\n  if (!findNewElements && mosElements.length > 0) {\n    return mosElements.map((mosEl) => mosEl.element);\n  }\n\n  // Otherwise, query DOM directly\n  return Array.from(document.querySelectorAll<HTMLElement>(\"[data-mos]\"));\n}\n\n// ===================================================================\n// ELEMENT PREPARATION (AOS-STYLE)\n// ===================================================================\n\n/**\n * Prepares all MOS elements for animation tracking (AOS-style prepare function)\n * Finds elements, calculates positions, sets initial states, and stores everything\n * in a unified array\n */\nexport function prepareElements(elements: HTMLElement[], options: MosOptions): MosElement[] {\n  // Clear previous prepared elements\n  mosElements = [];\n\n  // Prepare each element\n  elements.forEach((element) => {\n    const mosElement = prepareElement(element, options);\n    if (mosElement) {\n      mosElements.push(mosElement);\n    }\n  });\n\n  return mosElements;\n}\n\n/**\n * Prepares a single element for MOS tracking\n * Calculates positions, resolves options, and creates MosElement object\n */\nexport function prepareElement(element: HTMLElement, options: MosOptions): MosElement | null {\n  const animationName = element.getAttribute(\"data-mos\");\n  if (!animationName) return null;\n\n  // Resolve element-specific options using existing attributes system\n  const elementOptions = resolveElementOptions(element, options);\n\n  // Calculate scroll trigger positions\n  const position = {\n    in: getPositionIn(element, elementOptions),\n    out:\n      elementOptions.mirror && !elementOptions.once\n        ? getPositionOut(element, elementOptions)\n        : (false as const),\n  };\n\n  // Create unified MOS element object\n  const mosElement: MosElement = {\n    element,\n    options: elementOptions,\n    position,\n    animated: false,\n    isReversing: false,\n    controls: undefined,\n  };\n\n  return mosElement;\n}\n\n// ===================================================================\n// ELEMENT ACCESS AND MANAGEMENT\n// ===================================================================\n\n/**\n * Gets all prepared elements\n */\nexport function getPreparedElements(): MosElement[] {\n  return mosElements;\n}\n\n/**\n * Finds a prepared element by its DOM element\n */\nexport function findPreparedElement(element: HTMLElement): MosElement | undefined {\n  return mosElements.find((mosEl) => mosEl.element === element);\n}\n\n/**\n * Updates the prepared elements array (for position recalculation)\n */\nexport function updatePreparedElements(elements: MosElement[]): void {\n  mosElements = elements;\n}\n\n/**\n * Clears all prepared elements\n */\nexport function clearAllElements(): void {\n  mosElements = [];\n}\n\nexport default {\n  clearAllElements,\n  findPreparedElement,\n  getMosElements,\n  getPreparedElements,\n  prepareElement,\n  prepareElements,\n  updatePreparedElements,\n};\n", "import type { DOMKeyframesDefinition } from \"motion\";\n\nimport { KEYFRAMES_PRESETS } from \"./constants.js\";\nimport type { ElementOptions } from \"./types.js\";\n\n// ------------------- Custom preset registry -------------------\nconst customKeyframes: Record<string, DOMKeyframesDefinition> = {};\n\n/**\n * Register custom animation keyframes by name.\n * Must be called **before** `MOS.init()` so the name can be picked up when elements are observed.\n * Supplying the same name twice will overwrite the previous definition.\n */\nexport function registerKeyframes(name: string, definition: DOMKeyframesDefinition): void {\n  if (!name || name.trim() === \"\") throw new Error(\"Custom keyframes name must be non-empty\");\n  customKeyframes[name] = definition;\n}\n\n/**\n * Resolve a preset first from user-registered presets, then fall back to built-ins.\n */\nexport function resolveKeyframes(name: string): DOMKeyframesDefinition {\n  return (\n    customKeyframes[name] ??\n    KEYFRAMES_PRESETS[name] ??\n    (KEYFRAMES_PRESETS.fade as DOMKeyframesDefinition)\n  );\n}\n\n/**\n * Get keyframes with custom distance applied\n */\nexport function getKeyframesWithDistance(opts: ElementOptions, resolvedKeyframes: any): any {\n  let keyframes = resolvedKeyframes;\n\n  switch (opts.keyframes) {\n    case \"fade-up\":\n      keyframes = { opacity: [0, 1], translateY: [opts.distance, 0] };\n      break;\n    case \"fade-down\":\n      keyframes = { opacity: [0, 1], translateY: [-opts.distance, 0] };\n      break;\n    case \"fade-left\":\n      keyframes = { opacity: [0, 1], translateX: [opts.distance, 0] };\n      break;\n    case \"fade-right\":\n      keyframes = { opacity: [0, 1], translateX: [-opts.distance, 0] };\n      break;\n    // diagonal fades\n    case \"fade-up-right\":\n      keyframes = {\n        opacity: [0, 1],\n        translateY: [opts.distance, 0],\n        translateX: [-opts.distance, 0],\n      };\n      break;\n    case \"fade-up-left\":\n      keyframes = {\n        opacity: [0, 1],\n        translateY: [opts.distance, 0],\n        translateX: [opts.distance, 0],\n      };\n      break;\n    case \"fade-down-right\":\n      keyframes = {\n        opacity: [0, 1],\n        translateY: [-opts.distance, 0],\n        translateX: [-opts.distance, 0],\n      };\n      break;\n    case \"fade-down-left\":\n      keyframes = {\n        opacity: [0, 1],\n        translateY: [-opts.distance, 0],\n        translateX: [opts.distance, 0],\n      };\n      break;\n    // slides\n    case \"slide-up\":\n      keyframes = { translateY: [opts.distance, 0] };\n      break;\n    case \"slide-down\":\n      keyframes = { translateY: [-opts.distance, 0] };\n      break;\n    case \"slide-left\":\n      keyframes = { translateX: [opts.distance, 0] };\n      break;\n    case \"slide-right\":\n      keyframes = { translateX: [-opts.distance, 0] };\n      break;\n    // zoom directional\n    case \"zoom-in-up\":\n    case \"zoom-out-up\":\n      keyframes = { ...resolvedKeyframes, translateY: [opts.distance, 0] };\n      break;\n    case \"zoom-in-down\":\n    case \"zoom-out-down\":\n      keyframes = { ...resolvedKeyframes, translateY: [-opts.distance, 0] };\n      break;\n    case \"zoom-in-left\":\n    case \"zoom-out-left\":\n      keyframes = { ...resolvedKeyframes, translateX: [opts.distance, 0] };\n      break;\n    case \"zoom-in-right\":\n    case \"zoom-out-right\":\n      keyframes = { ...resolvedKeyframes, translateX: [-opts.distance, 0] };\n      break;\n  }\n\n  return keyframes;\n}\n\nexport default {\n  getKeyframesWithDistance,\n  registerKeyframes,\n  resolveKeyframes,\n};\n", "import { refreshHard } from \"../index.js\";\n\n/**\n * DOM mutation observer for detecting new elements added to the page\n */\nlet domObserver: MutationObserver | null = null;\n\n/**\n * Check if any nodes in the provided list contain data-mos attributes\n * Recursively checks children as well\n */\nfunction containsMosNode(nodes: NodeList | HTMLElement[]): boolean {\n  for (let i = 0; i < nodes.length; i++) {\n    const currentNode = nodes[i] as HTMLElement;\n\n    // Skip non-element nodes (text nodes, comments, etc.)\n    if (currentNode.nodeType !== Node.ELEMENT_NODE) {\n      continue;\n    }\n\n    // Check if current node has data-mos attribute\n    if (currentNode.dataset && currentNode.dataset.mos) {\n      return true;\n    }\n\n    // Recursively check children\n    if (currentNode.children && currentNode.children.length > 0) {\n      const childrenArray = Array.from(currentNode.children) as HTMLElement[];\n      if (containsMosNode(childrenArray)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Handle mutation observer changes - only trigger refresh if data-mos elements are affected\n */\nfunction handleMutationObserverChanges(mutations: MutationRecord[]): void {\n  if (!mutations || mutations.length === 0) {\n    return;\n  }\n\n  let shouldRefresh = false;\n\n  for (const mutation of mutations) {\n    const addedNodes = Array.from(mutation.addedNodes) as HTMLElement[];\n    const removedNodes = Array.from(mutation.removedNodes) as HTMLElement[];\n    const allNodes = [...addedNodes, ...removedNodes];\n\n    // Check if any added or removed nodes contain data-mos elements\n    if (containsMosNode(allNodes)) {\n      shouldRefresh = true;\n      break;\n    }\n  }\n\n  // Only trigger expensive refresh when data-mos elements are actually affected\n  if (shouldRefresh) {\n    refreshHard();\n  }\n}\n\n/**\n * Start DOM mutation observer to watch for data-mos elements being added/removed\n * Uses AOS-like targeted observation to avoid unnecessary refreshes\n */\nexport function startDomObserver(): void {\n  // Clean up existing observer\n  domObserver?.disconnect();\n\n  // Create new observer with targeted mutation handling\n  domObserver = new MutationObserver(handleMutationObserverChanges);\n\n  // Observe document.documentElement (like AOS) for better performance than document.body\n  domObserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true,\n  });\n}\n\nexport default {\n  startDomObserver,\n};\n", "/**\n * Helper utilities for MOS library.\n */\n\nimport type { DeviceDisable } from \"./types.js\";\n\n/**\n * Simple throttle function (no external dependencies)\n * Ensures function is called at most once per delay period\n */\nexport function throttle<T extends (...args: any[]) => void>(\n  func: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  let timeoutId: number | null = null;\n  let lastExecTime = 0;\n\n  return (...args: Parameters<T>) => {\n    const currentTime = Date.now();\n\n    if (currentTime - lastExecTime > delay) {\n      func(...args);\n      lastExecTime = currentTime;\n    } else {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      timeoutId = window.setTimeout(\n        () => {\n          func(...args);\n          lastExecTime = Date.now();\n          timeoutId = null;\n        },\n        delay - (currentTime - lastExecTime),\n      );\n    }\n  };\n}\n\n/**\n * Simple debounce function (no external dependencies)\n * Ensures function is called only after delay period of inactivity\n */\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  let timeoutId: number | null = null;\n\n  return (...args: Parameters<T>) => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = window.setTimeout(() => func(...args), delay);\n  };\n}\n\n/**\n * Evaluate whether MOS should be disabled for current environment.\n * Mirrors AOS `disable` option behaviour.\n */\n/**\n * Determine if MOS should be disabled for the current viewport.\n */\nexport function isDisabled(disable: DeviceDisable): boolean {\n  if (typeof disable === \"boolean\") return disable;\n  if (typeof disable === \"function\") {\n    try {\n      return !!disable();\n    } catch {\n      return false;\n    }\n  }\n  if (typeof window === \"undefined\") return false;\n  const width = window.innerWidth;\n  switch (disable) {\n    case \"phone\":\n      return width < 768;\n    case \"tablet\":\n      return width >= 768 && width < 1024;\n    case \"mobile\":\n      return width < 1024;\n    default:\n      return false;\n  }\n}\n\n/**\n * Remove all `data-mos*` attributes from the given element, used when MOS is\n * globally disabled so that any CSS rules tied to these attributes stop\n * applying.\n */\nexport function removeMosAttributes(el: Element): void {\n  for (const { name } of Array.from(el.attributes)) {\n    if (name.startsWith(\"data-mos\")) {\n      el.removeAttribute(name);\n    }\n  }\n}\n\nexport default {\n  debounce,\n  isDisabled,\n  removeMosAttributes,\n  throttle,\n};\n", "// ===================================================================\n// SCROLL-BASED ANIMATION HANDLER\n// ===================================================================\n// This module handles scroll-based animation triggering using a custom\n// AOS-style approach. It replaces Motion's inView with direct scroll\n// event handling for better control over animation timing and state.\n\nimport { play, reverse, setFinalState, setInitialState } from \"./animations.js\";\nimport { DEFAULT_OPTIONS } from \"./constants.js\";\nimport { getPreparedElements } from \"./elements.js\";\nimport { getPositionIn, getPositionOut, isElementAboveViewport } from \"./position-calculator.js\";\nimport type { MosElement } from \"./types.js\";\nimport { throttle } from \"./utils.js\";\n\n// ===================================================================\n// MODULE STATE\n// ===================================================================\n\n/**\n * Reference to the active scroll event handler (for cleanup)\n */\nlet activeScrollHandler: ((...args: any[]) => void) | null = null;\n\n/**\n * Current throttle delay for scroll events (configurable)\n */\nlet currentThrottleDelay = DEFAULT_OPTIONS.throttleDelay;\n\n// ===================================================================\n// ANIMATION STATE MANAGEMENT\n// ===================================================================\n\n/**\n * Determines and applies the correct animation state based on scroll position\n * Uses AOS-like logic with support for mirror functionality\n * @param elementData - The element data containing state and configuration\n * @param scrollY - Current vertical scroll position\n */\nfunction updateElementAnimationState(elementData: MosElement, scrollY: number): void {\n  const { options, position } = elementData;\n\n  /**\n   * Hides the element by reversing its animation\n   * Only triggers if element is currently animated and not already reversing\n   */\n  const hideElement = (): void => {\n    if (!elementData.animated || elementData.isReversing) return;\n\n    // Start reverse animation\n    reverse(elementData);\n  };\n\n  /**\n   * Shows the element by playing its animation\n   * Only triggers if element is not already animated or is currently reversing\n   */\n  const showElement = (): void => {\n    if (elementData.animated && !elementData.isReversing) return;\n\n    // Start forward animation\n    play(elementData);\n  };\n\n  if (\n    options.mirror &&\n    position.out !== undefined &&\n    position.out !== false &&\n    scrollY >= position.out &&\n    !options.once\n  ) {\n    hideElement();\n  } else if (position.in !== undefined && scrollY >= position.in) {\n    showElement();\n  } else if (elementData.animated && !options.once) {\n    hideElement();\n  }\n}\n\n// ===================================================================\n// SCROLL EVENT HANDLING\n// ===================================================================\n\n/**\n * Main scroll event handler that processes all tracked elements\n * Called on every scroll event (throttled for performance)\n */\nfunction processScrollEvent(): void {\n  const currentScrollY = window.scrollY;\n\n  // Update animation state for all prepared elements\n  getPreparedElements().forEach((elementData) => {\n    updateElementAnimationState(elementData, currentScrollY);\n  });\n}\n\n// ===================================================================\n// ELEMENT PREPARATION AND POSITIONING\n// ===================================================================\n\n/**\n * Calculates the scroll positions that will trigger animations for an element\n * @param elementData - The element data to calculate positions for\n */\nfunction calculateElementTriggerPositions(elementData: MosElement): void {\n  const { element, options } = elementData;\n\n  elementData.position = {\n    // Calculate entry position (when element should animate in)\n    in: getPositionIn(element, options),\n    // Calculate exit position (when element should animate out) - only if mirror is enabled\n    out: options.mirror && !options.once ? getPositionOut(element, options) : false,\n  };\n}\n\n/**\n * Sets the initial animation state for an element based on its viewport position\n * @param elementData - The element data to set initial state for\n */\nfunction setElementInitialState(elementData: MosElement): void {\n  const { element, options } = elementData;\n\n  if (isElementAboveViewport(element) && !options.mirror) {\n    // Element is above viewport - set to final animated state immediately\n    setFinalState(elementData);\n  } else {\n    // Element is in or below viewport - set to initial state\n    setInitialState(elementData);\n  }\n}\n\n/**\n * Refreshes all tracked elements by recalculating positions and states\n * Called when the library needs to update after configuration changes\n * Preserves current animation states to prevent flicker during resize\n */\nexport function evaluateElementPositions(): void {\n  getPreparedElements().forEach((elementData) => {\n    calculateElementTriggerPositions(elementData);\n\n    // Only reset initial state for elements that haven't been animated yet\n    // This prevents flicker during resize for already-animated elements\n    if (!elementData.animated) {\n      setElementInitialState(elementData);\n    }\n  });\n\n  // Process current scroll position to animate elements already in viewport\n  processScrollEvent();\n}\n\n// ===================================================================\n// CONFIGURATION MANAGEMENT\n// ===================================================================\n\n/**\n * Updates the throttle delay used by the scroll handler\n * Called from the main initialization to apply user configuration\n * @param throttleDelay - Delay in ms for throttling scroll events\n */\nexport function updateScrollHandlerDelays(throttleDelay: number): void {\n  currentThrottleDelay = throttleDelay;\n}\n\n// ===================================================================\n// SCROLL HANDLER LIFECYCLE\n// ===================================================================\n\n/**\n * Initializes the scroll event handler system with throttling\n * Sets up listener for scroll events only (layout changes handled in index.ts)\n */\nexport function ensureScrollHandlerActive(): void {\n  // Prevent multiple initializations\n  if (activeScrollHandler) return;\n\n  // Create throttled scroll handler for performance\n  const throttledScrollHandler = throttle(processScrollEvent, currentThrottleDelay);\n\n  // Set up scroll event listener\n  window.addEventListener(\"scroll\", throttledScrollHandler, { passive: true });\n\n  // Store reference for cleanup\n  activeScrollHandler = throttledScrollHandler;\n}\n\n/**\n * Cleans up the scroll handler system and removes all event listeners\n * Resets all tracking state to initial conditions\n */\nexport function cleanupScrollHandler(): void {\n  if (activeScrollHandler) {\n    // Remove scroll event listener\n    window.removeEventListener(\"scroll\", activeScrollHandler);\n\n    // Clear handler reference\n    activeScrollHandler = null;\n  }\n}\n\nexport default {\n  cleanupScrollHandler,\n  ensureScrollHandlerActive,\n  evaluateElementPositions,\n  updateScrollHandlerDelays,\n};\n", "// ===================================================================\n// MOTION-ON-SCROLL (MOS) - Main Entry Point\n// ===================================================================\n// This file provides the public API for the Motion-on-Scroll library.\n// It handles initialization, configuration, and lifecycle management.\n\nimport { registerAnimation } from \"./helpers/animations.js\";\nimport { DEFAULT_OPTIONS } from \"./helpers/constants.js\";\nimport { registerEasing } from \"./helpers/easing.js\";\nimport { clearAllElements, getMosElements, prepareElements } from \"./helpers/elements.js\";\nimport { registerKeyframes } from \"./helpers/keyframes.js\";\nimport { startDomObserver } from \"./helpers/observer.js\";\nimport {\n  cleanupScrollHandler,\n  ensureScrollHandlerActive,\n  evaluateElementPositions,\n  updateScrollHandlerDelays,\n} from \"./helpers/scroll-handler.js\";\nimport type { MosOptions, PartialMosOptions } from \"./helpers/types.js\";\nimport { debounce, isDisabled, removeMosAttributes } from \"./helpers/utils.js\";\n\n// ===================================================================\n// LIBRARY STATE MANAGEMENT\n// ===================================================================\n\n/**\n * Global configuration options merged from all init() calls\n */\nlet libraryConfig: MosOptions = DEFAULT_OPTIONS;\n\n/**\n * Tracks whether the library has been initialized and is actively running\n */\nlet isLibraryActive = false;\n\n// ===================================================================\n// CONFIGURATION AND TIME UNITS\n// ===================================================================\n\n/**\n * Adjusts duration and delay values when using seconds instead of milliseconds\n * Only applied on first initialization when timeUnits is set to \"s\"\n * @param config - The configuration object to potentially modify\n */\nfunction adjustTimeUnitsOnFirstInit(config: MosOptions, newOptions: PartialMosOptions): void {\n  if (isLibraryActive || config.timeUnits !== \"s\") return;\n\n  // Convert default duration from ms to seconds if not explicitly set\n  if (newOptions.duration == null) {\n    config.duration = DEFAULT_OPTIONS.duration / 1000;\n  }\n\n  // Convert default delay from ms to seconds if not explicitly set\n  if (newOptions.delay == null) {\n    config.delay = DEFAULT_OPTIONS.delay / 1000;\n  }\n}\n\n/**\n * Recalculates element positions after layout changes\n * Called on window resize and orientation change\n */\nexport function handleLayoutChange(): void {\n  if (isLibraryActive) {\n    evaluateElementPositions();\n  }\n}\n\n/**\n * Sets up event listeners for layout changes (resize, orientation)\n * Uses debounced handlers to prevent excessive recalculations\n */\nfunction setupLayoutChangeListeners(): void {\n  const debounceDelay = libraryConfig.debounceDelay;\n  const debouncedHandler = debounce(handleLayoutChange, debounceDelay);\n\n  window.addEventListener(\"resize\", debouncedHandler);\n  window.addEventListener(\"orientationchange\", debouncedHandler);\n}\n\n/**\n * Sets up the start event listener based on configuration\n * Handles both standard events (DOMContentLoaded, load) and custom events\n */\nexport function setupStartEventListener(): void {\n  const startEvent = libraryConfig.startEvent;\n\n  // If the desired event has already fired, bootstrap immediately\n  if (\n    (startEvent === \"DOMContentLoaded\" &&\n      [\"interactive\", \"complete\"].includes(document.readyState)) ||\n    (startEvent === \"load\" && document.readyState === \"complete\")\n  ) {\n    refresh(true);\n    return;\n  } else if (startEvent === \"load\") {\n    // Otherwise, attach listener for the start event\n    window.addEventListener(startEvent, () => refresh(true), { once: true });\n  } else {\n    document.addEventListener(startEvent, () => refresh(true), { once: true });\n  }\n}\n\n// ===================================================================\n// PUBLIC API\n// ===================================================================\n\n/**\n * Initializes the Motion-on-Scroll library with the given options\n * Can be called multiple times - options will be merged\n * @param options - Configuration options for the library\n * @returns Array of elements found in the DOM (for compatibility)\n */\nfunction init(options: PartialMosOptions = {}): HTMLElement[] {\n  // Merge new options with existing configuration\n  libraryConfig = { ...DEFAULT_OPTIONS, ...options };\n\n  // Handle time unit conversion on first initialization\n  adjustTimeUnitsOnFirstInit(libraryConfig, options);\n\n  // If already initialized, just refresh with new options\n  if (isLibraryActive) {\n    refresh();\n    return getMosElements(); // Return current DOM elements\n  }\n\n  // First time init - find elements and check for global disable\n  const foundElements = getMosElements();\n\n  // Handle global disable - clean up and exit early\n  if (isDisabled(libraryConfig.disable)) {\n    foundElements.forEach(removeMosAttributes);\n    return [];\n  }\n\n  // Set up event listeners\n  setupStartEventListener();\n  setupLayoutChangeListeners();\n\n  // Don't start mutation observer if disabled or not supported\n  if (!libraryConfig.disableMutationObserver && typeof MutationObserver !== \"undefined\") {\n    startDomObserver();\n  }\n\n  // Return current elements\n  return foundElements;\n}\n\n/**\n * Refreshes the library by updating element positions and re-initializing scroll system\n * Does NOT re-find elements - only updates existing tracked elements\n * @param shouldActivate - Whether this refresh should activate the library (if not already active)\n */\nfunction refresh(shouldActivate = false): void {\n  if (shouldActivate) isLibraryActive = true;\n  if (isLibraryActive) {\n    // Configure performance settings from library config\n    updateScrollHandlerDelays(libraryConfig.throttleDelay);\n\n    const foundElements = getMosElements();\n\n    // Use unified element system to prepare elements (reusing previously found elements)\n    prepareElements(foundElements, libraryConfig);\n\n    // Ensure scroll handler is active to process all prepared elements\n    ensureScrollHandlerActive();\n\n    // Calculate positions and set initial states for all elements\n    evaluateElementPositions();\n  }\n}\n\n/**\n * Performs a hard refresh - re-finds all MOS elements and completely re-initializes\n * This is a full re-initialization that discovers new elements in the DOM\n */\nfunction refreshHard(): void {\n  // Re-find all MOS elements in case any were added or removed\n  const foundElements = getMosElements(true);\n\n  // Handle global disable - clean up and exit early\n  if (isDisabled(libraryConfig.disable)) {\n    foundElements.forEach(removeMosAttributes);\n    return;\n  }\n\n  // Clear existing prepared elements and clean up scroll handlers\n  clearAllElements();\n  cleanupScrollHandler();\n\n  // re-calculate positions and init scroll system\n  refresh();\n}\n\n// ===================================================================\n// EXPORTS\n// ===================================================================\n\nexport const MOS = {\n  init,\n  refresh,\n  refreshHard,\n  registerKeyframes,\n  registerEasing,\n  registerAnimation,\n};\n\nexport { init, refresh, refreshHard, registerAnimation, registerEasing, registerKeyframes };\n\nexport default MOS;\n"],
  "mappings": ";;;;;;ACQO,IAAMA,IAA8B,EACzC,QAAQ,KACR,UAAU,KACV,UAAU,KACV,OAAO,GACP,QAAQ,QACR,MAAM,OACN,QAAQ,OACR,SAAS,OACT,yBAAyB,OACzB,WAAW,MACX,YAAY,oBACZ,eAAe,IACf,eAAe,GACjB;AAdO,IAoBMC,IAAmD,EAC9D,QAAQ,UACR,MAAM,QACN,WAAW,UACX,YAAY,WACZ,eAAe,aACf,WAAW,UACX,YAAY,WACZ,eAAe,aACf,WAAW,UACX,YAAY,WACZ,eAAe,aACf,YAAY,cAEZ,gBAAgB,CAAC,KAAK,OAAO,OAAO,KAAK,GACzC,iBAAiB,CAAC,OAAO,OAAO,MAAM,KAAK,GAC3C,oBAAoB,CAAC,MAAM,OAAO,OAAO,IAAI,GAE7C,gBAAgB,CAAC,MAAM,GAAG,OAAO,KAAK,GACtC,iBAAiB,CAAC,MAAM,OAAO,OAAO,CAAC,GACvC,oBAAoB,CAAC,OAAO,MAAM,MAAM,IAAI,GAE5C,gBAAgB,CAAC,MAAM,OAAO,MAAM,IAAI,GACxC,iBAAiB,CAAC,MAAM,MAAM,MAAM,IAAI,GACxC,oBAAoB,CAAC,OAAO,MAAM,OAAO,KAAK,GAE9C,iBAAiB,CAAC,MAAM,OAAO,MAAM,IAAI,GACzC,kBAAkB,CAAC,MAAM,MAAM,MAAM,IAAI,GACzC,qBAAqB,CAAC,OAAO,MAAM,OAAO,KAAK,GAE/C,iBAAiB,CAAC,MAAM,OAAO,MAAM,IAAI,GACzC,kBAAkB,CAAC,MAAM,MAAM,MAAM,IAAI,GACzC,qBAAqB,CAAC,OAAO,MAAM,OAAO,KAAK,EACjD;AArDO,IAyDMC,IAA4D,EAEvE,MAAM,EAAE,SAAS,CAAC,GAAG,CAAC,EAAE,GACxB,WAAW,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,GACnD,aAAa,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,EAAE,GACtD,aAAa,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,GACrD,cAAc,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,EAAE,GACvD,iBAAiB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,EAAE,GAChF,gBAAgB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,GAC9E,mBAAmB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,EAAE,GACnF,kBAAkB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,GAEjF,WAAW,EAAE,aAAa,CAAC,MAAM,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC,EAAE,GAC3D,aAAa,EAAE,aAAa,CAAC,MAAM,IAAI,GAAG,SAAS,CAAC,KAAK,CAAC,EAAE,GAC5D,aAAa,EAAE,aAAa,CAAC,MAAM,IAAI,GAAG,SAAS,CAAC,KAAK,CAAC,EAAE,GAC5D,cAAc,EAAE,aAAa,CAAC,MAAM,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC,EAAE,GAE9D,YAAY,EAAE,YAAY,CAAC,KAAK,CAAC,EAAE,GACnC,cAAc,EAAE,YAAY,CAAC,MAAM,CAAC,EAAE,GACtC,cAAc,EAAE,YAAY,CAAC,KAAK,CAAC,EAAE,GACrC,eAAe,EAAE,YAAY,CAAC,MAAM,CAAC,EAAE,GAEvC,WAAW,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,GAC9C,cAAc,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,GACvE,gBAAgB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,EAAE,GAC1E,gBAAgB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,GACzE,iBAAiB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,EAAE,GAC3E,YAAY,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,GAC/C,eAAe,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,GACxE,iBAAiB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,EAAE,GAC3E,iBAAiB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,GAC1E,kBAAkB,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,EAAE,EAC9E;ACrFA,IAAMC,IAAkD,CAAC;AAYlD,SAASC,EAAcC,GAAyC;AACrE,MAAIA,KAAS,QAAQ,OAAOA,KAAU,SAAU;AAGhD,MAAI,OAAO,UAAU,eAAe,KAAKF,GAAeE,CAAK,EAAG,QAAOF,EAAcE,CAAK;AAE1F,MAAI,OAAO,UAAU,eAAe,KAAKJ,GAASI,CAAK,EACrD,QAAOJ,EAAQI,CAA6B;AAE9C,MAAMC,IAAYD,EAAM,KAAK,GAGvBE,IAAaD,EAAU,MAC3B,oFACF;AACA,MAAIC,GAAY;AACd,QAAMC,IAAOD,EAAW,MAAM,GAAG,CAAC,EAAE,IAAI,MAAM;AAC9C,QAAIC,EAAK,WAAW,KAAKA,EAAK,MAAOC,OAAM,OAAO,SAASA,CAAC,CAAC,EAC3D,QAAOD;EAEX;AAGA,MAAME,IAAaJ,EAAU,MAC3B,0EACF;AACA,MAAII,GAAY;AACd,QAAMF,IAAOE,EAAW,MAAM,GAAG,CAAC,EAAE,IAAI,MAAM;AAC9C,QAAIF,EAAK,WAAW,KAAKA,EAAK,MAAOC,OAAM,OAAO,SAASA,CAAC,CAAC,EAC3D,QAAOD;EAEX;AAGA,SAAO;AACT;AAuBO,SAASG,EAAeC,GAAcC,GAA6C;AACxF,MAAI,CAACD,KAAQA,EAAK,KAAK,MAAM,GAAI,OAAM,IAAI,MAAM,sCAAsC;AAGvF,MAAI,OAAOC,KAAe,UAAU;AAClC,QAAMC,IAAWV,EAAcS,CAAU;AACzC,QAAIC,MAAa,KACf,OAAM,IAAI,MAAM,+BAA+BD,CAAU,GAAG;AAE9DV,MAAcS,CAAI,IAAIE;EACxB,MAEEX,GAAcS,CAAI,IAAIC;AAE1B;AC5FA,SAASE,EAAWC,GAAiBJ,GAAkC;AACrE,MAAMK,IAAMD,EAAG,QAAQJ,CAA+B;AACtD,MAAIK,KAAO,KAAM;AACjB,MAAMC,IAAM,WAAWD,CAAG;AAC1B,SAAO,OAAO,SAASC,CAAG,IAAIA,IAAM;AACtC;AAEO,SAASC,EAAsBH,GAAiBI,GAA2C;AAChG,MAAMC,IAAYL,EAAG,QAAQ,KAAkB,KAAK,QAE9CM,IAAgC,EACpC,QAAQP,EAAWC,GAAI,GAAG,KAAW,QAAQ,GAC7C,UAAUD,EAAWC,GAAI,GAAG,KAAW,UAAU,GACjD,OAAOD,EAAWC,GAAI,GAAG,KAAW,OAAO,GAC3C,UAAUD,EAAWC,GAAI,GAAG,KAAW,UAAU,GACjD,QAAQA,EAAG,QAAQ,GAAG,KAAW,QAAe,GAChD,QAAQA,EAAG,QAAQ,GAAG,KAAW,QAAe,GAChD,MAAMA,EAAG,aAAa,QAAQ,KAAW,OAAO,IAC5CA,EAAG,aAAa,QAAQ,KAAW,OAAO,MAAM,UAChD,QACJ,QAAQA,EAAG,aAAa,QAAQ,KAAW,SAAS,IAChDA,EAAG,aAAa,QAAQ,KAAW,SAAS,MAAM,UAClD,QACJ,iBAAiBA,EAAG,QAAQ,GAAG,KAAW,iBAAwB,EACpE;AAIA,SAAO,EAAE,GAFM,EAAE,GAAGhB,GAAiB,GAAGoB,GAAQ,GAAGG,GAAeD,CAAI,EAAE,GAEpD,WAAAD,EAAU;AAChC;AAEA,SAASE,GAA8CC,GAAoB;AACzE,MAAMC,IAAqB,CAAC;AAC5B,WAAWC,KAAKF,EACVA,GAAIE,CAAC,MAAM,WAAWD,EAAOC,CAAC,IAAIF,EAAIE,CAAC;AAE7C,SAAOD;AACT;AC9BO,SAASE,EAAiBX,GAAgD;AAC/E,MAAIY,IAAI,GACJC,IAAI,GACJC,IAAUd;AAEd,SAAOc,KAAW,CAAC,MAAMA,EAAQ,UAAU,KAAK,CAAC,MAAMA,EAAQ,SAAS,IACtEF,MAAKE,EAAQ,cAAcA,EAAQ,YAAY,SAASA,EAAQ,aAAa,IAC7ED,KAAKC,EAAQ,aAAaA,EAAQ,YAAY,SAASA,EAAQ,YAAY,IAC3EA,IAAUA,EAAQ;AAGpB,SAAO,EACL,KAAKD,GACL,MAAMD,EACR;AACF;AAKO,SAASG,EAAcf,GAAiBM,GAA8B;AAC3E,MAAMU,IAAe,OAAO,aACtBC,IAAYX,EAAK,SAAU,SAAS,cAA2BA,EAAK,MAAM,KAAKN,IAAMA,GAEvFkB,IAAeP,EAAiBM,CAAS,EAAE,MAAMD;AAGrD,UAAQV,EAAK,iBAAiB;IAC5B,KAAK;AAEH;IACF,KAAK;AACHY,WAAgBD,EAAU,eAAe;AACzC;IACF,KAAK;AACHC,WAAgBD,EAAU;AAC1B;IACF,KAAK;AACHC,WAAgBF,IAAe;AAC/B;IACF,KAAK;AACHE,WAAgBF,IAAe,IAAIC,EAAU,eAAe;AAC5D;IACF,KAAK;AACHC,WAAgBF,IAAe,IAAIC,EAAU;AAC7C;IACF,KAAK;AACHC,WAAgBF;AAChB;IACF,KAAK;AACHE,WAAgBF,IAAeC,EAAU;AACzC;IACF,KAAK;AACHC,WAAgBF,IAAeC,EAAU,eAAe;AACxD;EACJ;AAEA,SAAOC,IAAeZ,EAAK;AAC7B;AAKO,SAASa,EAAenB,GAAiBM,GAA8B;AAC5E,MAAMW,IAAYX,EAAK,SAAU,SAAS,cAA2BA,EAAK,MAAM,KAAKN,IAAMA;AAG3F,SAFyBW,EAAiBM,CAAS,EAAE,MAE3BA,EAAU,eAAeX,EAAK;AAC1D;AAKO,SAASc,EAAuBpB,GAA0B;AAG/D,SAFsBW,EAAiBX,CAAE,EACL,MAAMA,EAAG,eACtB,OAAO;AAChC;ACtEA,IAAIqB,IAA4B,CAAC;AAU1B,SAASC,EAAeC,IAA2B,OAAsB;AAE9E,SAAI,CAACA,KAAmBF,EAAY,SAAS,IACpCA,EAAY,IAAKG,OAAUA,EAAM,OAAO,IAI1C,MAAM,KAAK,SAAS,iBAA8B,YAAY,CAAC;AACxE;AAWO,SAASC,EAAgBC,GAAyBC,GAAmC;AAE1F,SAAAN,IAAc,CAAC,GAGfK,EAAS,QAASZ,OAAY;AAC5B,QAAMc,IAAaC,GAAef,GAASa,CAAO;AAC9CC,SACFP,EAAY,KAAKO,CAAU;EAE/B,CAAC,GAEMP;AACT;AAMO,SAASQ,GAAef,GAAsBa,GAAwC;AAE3F,MAAI,CADkBb,EAAQ,aAAa,UAAU,EACjC,QAAO;AAG3B,MAAMgB,IAAiB3B,EAAsBW,GAASa,CAAO,GAGvDI,IAAW,EACf,IAAIhB,EAAcD,GAASgB,CAAc,GACzC,KACEA,EAAe,UAAU,CAACA,EAAe,OACrCX,EAAeL,GAASgB,CAAc,IACrC,MACT;AAYA,SAT+B,EAC7B,SAAAhB,GACA,SAASgB,GACT,UAAAC,GACA,UAAU,OACV,aAAa,OACb,UAAU,OACZ;AAGF;AASO,SAASC,IAAoC;AAClD,SAAOX;AACT;AAKO,SAASY,EAAoBnB,GAA8C;AAChF,SAAOO,EAAY,KAAMG,OAAUA,EAAM,YAAYV,CAAO;AAC9D;AAYO,SAASoB,IAAyB;AACvCb,MAAc,CAAC;AACjB;ACvHA,IAAMc,IAA0D,CAAC;AAO1D,SAASC,EAAkBxC,GAAcC,GAA0C;AACxF,MAAI,CAACD,KAAQA,EAAK,KAAK,MAAM,GAAI,OAAM,IAAI,MAAM,yCAAyC;AAC1FuC,IAAgBvC,CAAI,IAAIC;AAC1B;AAKO,SAASwC,EAAiBzC,GAAsC;AACrE,SACEuC,EAAgBvC,CAAI,KACpBV,EAAkBU,CAAI,KACrBV,EAAkB;AAEvB;AAKO,SAASoD,EAAyBhC,GAAsBiC,GAA6B;AAC1F,MAAIlC,IAAYkC;AAEhB,UAAQjC,EAAK,WAAW;IACtB,KAAK;AACHD,UAAY,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAACC,EAAK,UAAU,CAAC,EAAE;AAC9D;IACF,KAAK;AACHD,UAAY,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,CAACC,EAAK,UAAU,CAAC,EAAE;AAC/D;IACF,KAAK;AACHD,UAAY,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAACC,EAAK,UAAU,CAAC,EAAE;AAC9D;IACF,KAAK;AACHD,UAAY,EAAE,SAAS,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,CAACC,EAAK,UAAU,CAAC,EAAE;AAC/D;IAEF,KAAK;AACHD,UAAY,EACV,SAAS,CAAC,GAAG,CAAC,GACd,YAAY,CAACC,EAAK,UAAU,CAAC,GAC7B,YAAY,CAAC,CAACA,EAAK,UAAU,CAAC,EAChC;AACA;IACF,KAAK;AACHD,UAAY,EACV,SAAS,CAAC,GAAG,CAAC,GACd,YAAY,CAACC,EAAK,UAAU,CAAC,GAC7B,YAAY,CAACA,EAAK,UAAU,CAAC,EAC/B;AACA;IACF,KAAK;AACHD,UAAY,EACV,SAAS,CAAC,GAAG,CAAC,GACd,YAAY,CAAC,CAACC,EAAK,UAAU,CAAC,GAC9B,YAAY,CAAC,CAACA,EAAK,UAAU,CAAC,EAChC;AACA;IACF,KAAK;AACHD,UAAY,EACV,SAAS,CAAC,GAAG,CAAC,GACd,YAAY,CAAC,CAACC,EAAK,UAAU,CAAC,GAC9B,YAAY,CAACA,EAAK,UAAU,CAAC,EAC/B;AACA;IAEF,KAAK;AACHD,UAAY,EAAE,YAAY,CAACC,EAAK,UAAU,CAAC,EAAE;AAC7C;IACF,KAAK;AACHD,UAAY,EAAE,YAAY,CAAC,CAACC,EAAK,UAAU,CAAC,EAAE;AAC9C;IACF,KAAK;AACHD,UAAY,EAAE,YAAY,CAACC,EAAK,UAAU,CAAC,EAAE;AAC7C;IACF,KAAK;AACHD,UAAY,EAAE,YAAY,CAAC,CAACC,EAAK,UAAU,CAAC,EAAE;AAC9C;IAEF,KAAK;IACL,KAAK;AACHD,UAAY,EAAE,GAAGkC,GAAmB,YAAY,CAACjC,EAAK,UAAU,CAAC,EAAE;AACnE;IACF,KAAK;IACL,KAAK;AACHD,UAAY,EAAE,GAAGkC,GAAmB,YAAY,CAAC,CAACjC,EAAK,UAAU,CAAC,EAAE;AACpE;IACF,KAAK;IACL,KAAK;AACHD,UAAY,EAAE,GAAGkC,GAAmB,YAAY,CAACjC,EAAK,UAAU,CAAC,EAAE;AACnE;IACF,KAAK;IACL,KAAK;AACHD,UAAY,EAAE,GAAGkC,GAAmB,YAAY,CAAC,CAACjC,EAAK,UAAU,CAAC,EAAE;AACpE;EACJ;AAEA,SAAOD;AACT;AN7EA,IAAMmC,IAAmB,oBAAI;AAA7B,IAMMC,IAA4D,CAAC;AAsB5D,SAASC,EAAkB9C,GAAc+C,GAAiC;AAC/E,MAAI,CAAC/C,KAAQA,EAAK,KAAK,MAAM,GAC3B,OAAM,IAAI,MAAM,yCAAyC;AAE3D6C,IAAwB7C,CAAI,IAAI+C;AAClC;AAcA,SAASC,EACP9B,GACAa,GACkC;AAClC,MAAMC,IAAaK,EAAoBnB,CAAO;AAC9C,MAAI,CAACc,EAAY,QAAO;AAGxB,MAAIA,EAAW,SACb,QAAOA,EAAW;AAIpB,MAAMiB,IAAWC,GAAwBhC,GAASa,CAAO;AACzD,SAAKkB,KAGLjB,EAAW,WAAWiB,GAEfA,KALe;AAMxB;AAaO,SAASE,EAAgBnB,GAA8B;AAC5D,MAAM,EAAE,SAAAd,GAAS,SAAAa,EAAQ,IAAIC;AAG7B,MAAIY,EAAiB,IAAI1B,CAAO,EAAG;AAEnC,MAAM+B,IAAWD,EAAwB9B,GAASa,CAAO;AACpDkB,QAILA,EAAS,MAAM,GAGfjB,EAAW,WAAW,OACtBA,EAAW,cAAc;AAC3B;AAUA,SAASoB,EACPlC,GACA+B,GACAlB,GACM;AACNkB,IAAS,SACN,KAAK,MAAM;AACV,QAAMjB,IAAaK,EAAoBnB,CAAO;AACzCc,UAEDA,EAAW,cACbqB,GAAiCnC,GAAS+B,GAAUjB,CAAU,IAE9DsB,GAAiCpC,GAAS+B,GAAUlB,CAAO;EAE/D,CAAC,EACA,MAAM,MAAM;AACXwB,OAA4BrC,CAAO;EACrC,CAAC;AACL;AAMA,SAASmC,GACPnC,GACA+B,GACAjB,GACM;AAENiB,IAAS,OAAO,GAChBA,EAAS,MAAM,GACfL,EAAiB,OAAO1B,CAAO,GAC/BA,EAAQ,UAAU,OAAO,aAAa,GAGtCc,EAAW,cAAc,OACzBA,EAAW,WAAW;AACxB;AAMA,SAASsB,GACPpC,GACA+B,GACAlB,GACM;AACFA,IAAQ,QAEVkB,EAAS,KAAK,GAIhBL,EAAiB,OAAO1B,CAAO;AACjC;AAMA,SAASqC,GAA4BrC,GAA4B;AAC/D,MAAMc,IAAaK,EAAoBnB,CAAO;AAC1Cc,QACFA,EAAW,cAAc;AAE7B;AAcA,SAASkB,GACPhC,GACAa,GACkC;AAElC,MAAMyB,IAAkBX,EAAwBd,EAAQ,SAAS;AACjE,SAAIyB,IACKC,GAAsBvC,GAASa,GAASyB,CAAe,IAIzDE,GAAwBxC,GAASa,CAAO;AACjD;AASA,SAAS0B,GACPvC,GACAa,GACAgB,GAC2B;AAC3B,MAAME,IAAWF,EAAQ7B,GAASa,CAAO;AACzC,SAAAqB,EAAgClC,GAAS+B,GAAUlB,CAAO,GACnDkB;AACT;AAQA,SAASS,GACPxC,GACAa,GAC2B;AAE3B,MAAMtB,IAAYkD,GAA0B5B,CAAO,GAG7C6B,IAASC,GAAuB9B,CAAO,GAGvCkB,IAAWa,QAAQ5C,GAAST,GAAW,EAC3C,UAAUsB,EAAQ,cAAc,MAAMA,EAAQ,WAAWA,EAAQ,WAAW,KAC5E,OAAOA,EAAQ,cAAc,MAAMA,EAAQ,QAAQA,EAAQ,QAAQ,KACnE,MAAM6B,GACN,MAAM,OACR,CAAoB;AAGpB,SAAAR,EAAgClC,GAAS+B,GAAUlB,CAAO,GAEnDkB;AACT;AAQA,SAASU,GAA0B5B,GAA8B;AAC/D,MAAMY,IAAoBF,EAAiBV,EAAQ,SAAS;AAG5D,SAAIA,EAAQ,YAAY,QAAQA,EAAQ,aAAa3C,EAAgB,WAC5DsD,EAAyBX,GAASY,CAAiB,IAGrDA;AACT;AAQA,SAASkB,GAAuB9B,GAA8B;AAC5D,MAAI6B,IAASpE,EAAcuC,EAAQ,MAAM;AAGzC,SAAIA,EAAQ,UAAU6B,MAAW,SAC/B,QAAQ,KACN,yBAAyB,OAAO7B,EAAQ,MAAM,CAAC,gCAAgC3C,EAAgB,MAAM,IACvG,GACAwE,IAASpE,EAAcJ,EAAgB,MAAM,IAGxCwE,MAAW,OAAO,SAAYA;AACvC;AASO,SAASG,EAAc/B,GAA8B;AAC1D,MAAM,EAAE,SAAAd,GAAS,SAAAa,EAAQ,IAAIC,GAEvBiB,IAAWD,EAAwB9B,GAASa,CAAO;AACpDkB,QAILA,EAAS,SAAS,GAGlB/B,EAAQ,UAAU,IAAI,aAAa,GAGnCc,EAAW,WAAW,MACtBA,EAAW,cAAc;AAC3B;AAYO,SAASgC,EAAKhC,GAA8B;AACjD,MAAM,EAAE,SAAAd,GAAS,SAAAa,EAAQ,IAAIC,GAGvBiB,IAAWD,EAAwB9B,GAASa,CAAO;AACrD,GAACkB,KAEqBL,EAAiB,IAAI1B,CAAO,KAG7B,CAACc,EAAW,gBAGrCiB,EAAS,QAAQ,GACjBA,EAAS,KAAK,GAGdjB,EAAW,WAAW,MACtBA,EAAW,cAAc,OAGzBd,EAAQ,UAAU,IAAI,aAAa,GACnC0B,EAAiB,IAAI1B,GAAS+B,CAAQ;AACxC;AAQO,SAASgB,EAAQjC,GAA8B;AACpD,MAAI,CAACA,EAAW,SAAU;AAE1B,MAAM,EAAE,SAAAd,GAAS,UAAA+B,EAAS,IAAIjB;AAG9BA,IAAW,cAAc,MACzBiB,EAAS,QAAQ,IACjBA,EAAS,KAAK,GAGdL,EAAiB,IAAI1B,GAAS+B,CAAQ;AACxC;AOxYA,IAAIiB,IAAuC;AAM3C,SAASC,EAAgBC,GAA0C;AACjE,WAASC,IAAI,GAAGA,IAAID,EAAM,QAAQC,KAAK;AACrC,QAAMC,IAAcF,EAAMC,CAAC;AAG3B,QAAIC,EAAY,aAAa,KAAK,cAKlC;AAAA,UAAIA,EAAY,WAAWA,EAAY,QAAQ,IAC7C,QAAO;AAIT,UAAIA,EAAY,YAAYA,EAAY,SAAS,SAAS,GAAG;AAC3D,YAAMC,IAAgB,MAAM,KAAKD,EAAY,QAAQ;AACrD,YAAIH,EAAgBI,CAAa,EAC/B,QAAO;MAEX;IAAA;EACF;AAEA,SAAO;AACT;AAKA,SAASC,GAA8BC,GAAmC;AACxE,MAAI,CAACA,KAAaA,EAAU,WAAW,EACrC;AAGF,MAAIC,IAAgB;AAEpB,WAAWC,KAAYF,GAAW;AAChC,QAAMG,IAAa,MAAM,KAAKD,EAAS,UAAU,GAC3CE,IAAe,MAAM,KAAKF,EAAS,YAAY,GAC/CG,IAAW,CAAC,GAAGF,GAAY,GAAGC,CAAY;AAGhD,QAAIV,EAAgBW,CAAQ,GAAG;AAC7BJ,UAAgB;AAChB;IACF;EACF;AAGIA,OACFK,EAAY;AAEhB;AAMO,SAASC,IAAyB;AAEvCd,yBAAa,cAGbA,IAAc,IAAI,iBAAiBM,EAA6B,GAGhEN,EAAY,QAAQ,SAAS,iBAAiB,EAC5C,WAAW,MACX,SAAS,KACX,CAAC;AACH;ACvEO,SAASe,EACdC,GACAC,GACkC;AAClC,MAAIC,IAA2B,MAC3BC,IAAe;AAEnB,SAAO,IAAIC,MAAwB;AACjC,QAAMC,IAAc,KAAK,IAAI;AAEzBA,QAAcF,IAAeF,KAC/BD,EAAK,GAAGI,CAAI,GACZD,IAAeE,MAEXH,KACF,aAAaA,CAAS,GAExBA,IAAY,OAAO,WACjB,MAAM;AACJF,QAAK,GAAGI,CAAI,GACZD,IAAe,KAAK,IAAI,GACxBD,IAAY;IACd,GACAD,KAASI,IAAcF,EACzB;EAEJ;AACF;AAMO,SAASG,EACdN,GACAC,GACkC;AAClC,MAAIC,IAA2B;AAE/B,SAAO,IAAIE,MAAwB;AAC7BF,SACF,aAAaA,CAAS,GAExBA,IAAY,OAAO,WAAW,MAAMF,EAAK,GAAGI,CAAI,GAAGH,CAAK;EAC1D;AACF;AASO,SAASM,EAAWC,GAAiC;AAC1D,MAAI,OAAOA,KAAY,UAAW,QAAOA;AACzC,MAAI,OAAOA,KAAY,WACrB,KAAI;AACF,WAAO,CAAC,CAACA,EAAQ;EACnB,QAAQ;AACN,WAAO;EACT;AAEF,MAAI,OAAO,SAAW,IAAa,QAAO;AAC1C,MAAMC,IAAQ,OAAO;AACrB,UAAQD,GAAS;IACf,KAAK;AACH,aAAOC,IAAQ;IACjB,KAAK;AACH,aAAOA,KAAS,OAAOA,IAAQ;IACjC,KAAK;AACH,aAAOA,IAAQ;IACjB;AACE,aAAO;EACX;AACF;AAOO,SAASC,EAAoBxF,GAAmB;AACrD,WAAW,EAAE,MAAAJ,EAAK,KAAK,MAAM,KAAKI,EAAG,UAAU,EACzCJ,GAAK,WAAW,UAAU,KAC5BI,EAAG,gBAAgBJ,CAAI;AAG7B;AC7EA,IAAI6F,IAAyD;AAA7D,IAKIC,IAAuB1G,EAAgB;AAY3C,SAAS2G,GAA4BC,GAAyBC,GAAuB;AACnF,MAAM,EAAE,SAAAlE,GAAS,UAAAI,EAAS,IAAI6D,GAMxBE,IAAc,MAAY;AAC1B,KAACF,EAAY,YAAYA,EAAY,eAGzC/B,EAAQ+B,CAAW;EACrB,GAMMG,IAAc,MAAY;AAC1BH,MAAY,YAAY,CAACA,EAAY,eAGzChC,EAAKgC,CAAW;EAClB;AAGEjE,IAAQ,UACRI,EAAS,QAAQ,UACjBA,EAAS,QAAQ,SACjB8D,KAAW9D,EAAS,OACpB,CAACJ,EAAQ,OAETmE,EAAY,IACH/D,EAAS,OAAO,UAAa8D,KAAW9D,EAAS,KAC1DgE,EAAY,IACHH,EAAY,YAAY,CAACjE,EAAQ,QAC1CmE,EAAY;AAEhB;AAUA,SAASE,IAA2B;AAClC,MAAMC,IAAiB,OAAO;AAG9BjE,IAAoB,EAAE,QAAS4D,OAAgB;AAC7CD,OAA4BC,GAAaK,CAAc;EACzD,CAAC;AACH;AAUA,SAASC,GAAiCN,GAA+B;AACvE,MAAM,EAAE,SAAA9E,GAAS,SAAAa,EAAQ,IAAIiE;AAE7BA,IAAY,WAAW,EAErB,IAAI7E,EAAcD,GAASa,CAAO,GAElC,KAAKA,EAAQ,UAAU,CAACA,EAAQ,OAAOR,EAAeL,GAASa,CAAO,IAAI,MAC5E;AACF;AAMA,SAASwE,GAAuBP,GAA+B;AAC7D,MAAM,EAAE,SAAA9E,GAAS,SAAAa,EAAQ,IAAIiE;AAEzBxE,IAAuBN,CAAO,KAAK,CAACa,EAAQ,SAE9CgC,EAAciC,CAAW,IAGzB7C,EAAgB6C,CAAW;AAE/B;AAOO,SAASQ,IAAiC;AAC/CpE,IAAoB,EAAE,QAAS4D,OAAgB;AAC7CM,OAAiCN,CAAW,GAIvCA,EAAY,YACfO,GAAuBP,CAAW;EAEtC,CAAC,GAGDI,EAAmB;AACrB;AAWO,SAASK,EAA0BC,GAA6B;AACrEZ,MAAuBY;AACzB;AAUO,SAASC,KAAkC;AAEhD,MAAId,EAAqB;AAGzB,MAAMe,IAAyB3B,EAASmB,GAAoBN,CAAoB;AAGhF,SAAO,iBAAiB,UAAUc,GAAwB,EAAE,SAAS,KAAK,CAAC,GAG3Ef,IAAsBe;AACxB;AAMO,SAASC,KAA6B;AACvChB,QAEF,OAAO,oBAAoB,UAAUA,CAAmB,GAGxDA,IAAsB;AAE1B;ACzKA,IAAIiB,IAA4B1H;AAAhC,IAKI2H,IAAkB;AAWtB,SAASC,GAA2BC,GAAoBC,GAAqC;AACvFH,OAAmBE,EAAO,cAAc,QAGxCC,EAAW,YAAY,SACzBD,EAAO,WAAW7H,EAAgB,WAAW,MAI3C8H,EAAW,SAAS,SACtBD,EAAO,QAAQ7H,EAAgB,QAAQ;AAE3C;AAMO,SAAS+H,KAA2B;AACrCJ,OACFP,EAAyB;AAE7B;AAMA,SAASY,KAAmC;AAC1C,MAAMC,IAAgBP,EAAc,eAC9BQ,IAAmB9B,EAAS2B,IAAoBE,CAAa;AAEnE,SAAO,iBAAiB,UAAUC,CAAgB,GAClD,OAAO,iBAAiB,qBAAqBA,CAAgB;AAC/D;AAMO,SAASC,KAAgC;AAC9C,MAAMC,IAAaV,EAAc;AAGjC,MACGU,MAAe,sBACd,CAAC,eAAe,UAAU,EAAE,SAAS,SAAS,UAAU,KACzDA,MAAe,UAAU,SAAS,eAAe,YAClD;AACAC,MAAQ,IAAI;AACZ;EACF,MAAWD,OAAe,SAExB,OAAO,iBAAiBA,GAAY,MAAMC,EAAQ,IAAI,GAAG,EAAE,MAAM,KAAK,CAAC,IAEvE,SAAS,iBAAiBD,GAAY,MAAMC,EAAQ,IAAI,GAAG,EAAE,MAAM,KAAK,CAAC;AAE7E;AAYA,SAASC,GAAK3F,IAA6B,CAAC,GAAkB;AAQ5D,MANA+E,IAAgB,EAAE,GAAG1H,GAAiB,GAAG2C,EAAQ,GAGjDiF,GAA2BF,GAAe/E,CAAO,GAG7CgF,EACF,QAAAU,EAAQ,GACD/F,EAAe;AAIxB,MAAMiG,IAAgBjG,EAAe;AAGrC,SAAI+D,EAAWqB,EAAc,OAAO,KAClCa,EAAc,QAAQ/B,CAAmB,GAClC,CAAC,MAIV2B,GAAwB,GACxBH,GAA2B,GAGvB,CAACN,EAAc,2BAA2B,OAAO,mBAAqB,OACxE9B,EAAiB,GAIZ2C;AACT;AAOA,SAASF,EAAQG,IAAiB,OAAa;AAE7C,MADIA,MAAgBb,IAAkB,OAClCA,GAAiB;AAEnBN,MAA0BK,EAAc,aAAa;AAErD,QAAMa,IAAgBjG,EAAe;AAGrCG,MAAgB8F,GAAeb,CAAa,GAG5CH,GAA0B,GAG1BH,EAAyB;EAC3B;AACF;AAMA,SAASzB,IAAoB;AAE3B,MAAM4C,IAAgBjG,EAAe,IAAI;AAGzC,MAAI+D,EAAWqB,EAAc,OAAO,GAAG;AACrCa,MAAc,QAAQ/B,CAAmB;AACzC;EACF;AAGAtD,IAAiB,GACjBuE,GAAqB,GAGrBY,EAAQ;AACV;AAMO,IAAMI,KAAM,EACjB,MAAAH,IACA,SAAAD,GACA,aAAA1C,GACA,mBAAAvC,GACA,gBAAAzC,GACA,mBAAA+C,EACF;AAIA,IAAOgF,KAAQD;",
  "names": ["DEFAULT_OPTIONS", "EASINGS", "KEYFRAMES_PRESETS", "customEasings", "resolveEasing", "input", "candidate", "cubicMatch", "nums", "n", "arrayMatch", "registerEasing", "name", "definition", "resolved", "readNumber", "el", "raw", "val", "resolveElementOptions", "global", "keyframes", "opts", "cleanUndefined", "obj", "result", "k", "getElementOffset", "x", "y", "element", "getPositionIn", "windowHeight", "triggerEl", "triggerPoint", "getPositionOut", "isElementAboveViewport", "mosElements", "getMosElements", "findNewElements", "mosEl", "prepareElements", "elements", "options", "mosElement", "prepareElement", "elementOptions", "position", "getPreparedElements", "findPreparedElement", "clearAllElements", "customKeyframes", "registerKeyframes", "resolveKeyframes", "getKeyframesWithDistance", "resolvedKeyframes", "activeAnimations", "customAnimationRegistry", "registerAnimation", "factory", "ensureAnimationControls", "controls", "createAnimationControls", "setInitialState", "setupAnimationCompletionHandler", "handleReverseAnimationCompletion", "handleForwardAnimationCompletion", "handleAnimationInterruption", "customAnimation", "createCustomAnimation", "createKeyframeAnimation", "resolveAnimationKeyframes", "easing", "resolveAnimationEasing", "animate", "setFinalState", "play", "reverse", "domObserver", "containsMosNode", "nodes", "i", "currentNode", "childrenArray", "handleMutationObserverChanges", "mutations", "shouldRefresh", "mutation", "addedNodes", "removedNodes", "allNodes", "refreshHard", "startDomObserver", "throttle", "func", "delay", "timeoutId", "lastExecTime", "args", "currentTime", "debounce", "isDisabled", "disable", "width", "removeMosAttributes", "activeScrollHandler", "currentThrottleDelay", "updateElementAnimationState", "elementData", "scrollY", "hideElement", "showElement", "processScrollEvent", "currentScrollY", "calculateElementTriggerPositions", "setElementInitialState", "evaluateElementPositions", "updateScrollHandlerDelays", "throttleDelay", "ensureScrollHandlerActive", "throttledScrollHandler", "cleanupScrollHandler", "libraryConfig", "isLibraryActive", "adjustTimeUnitsOnFirstInit", "config", "newOptions", "handleLayoutChange", "setupLayoutChangeListeners", "debounceDelay", "debouncedHandler", "setupStartEventListener", "startEvent", "refresh", "init", "foundElements", "shouldActivate", "MOS", "index_default"]
}
