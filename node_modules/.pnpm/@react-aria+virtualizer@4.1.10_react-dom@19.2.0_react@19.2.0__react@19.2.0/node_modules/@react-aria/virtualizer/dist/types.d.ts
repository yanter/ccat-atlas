import { Direction, Key, RefObject, Collection } from "@react-types/shared";
import { LayoutInfo, Size, Rect, Layout, ReusableView } from "@react-stately/virtualizer";
import React, { CSSProperties, HTMLAttributes, ReactNode, RefObject as _RefObject1, JSX, ReactElement } from "react";
export type RTLOffsetType = 'negative' | 'positive-descending' | 'positive-ascending';
export function getRTLOffsetType(recalculate?: boolean): RTLOffsetType;
export function getScrollLeft(node: Element, direction: Direction): number;
export function setScrollLeft(node: Element, direction: Direction, scrollLeft: number): void;
interface IVirtualizer {
    updateItemSize(key: Key, size: Size): void;
}
export interface VirtualizerItemOptions {
    layoutInfo: LayoutInfo | null;
    virtualizer: IVirtualizer;
    ref: RefObject<HTMLElement | null>;
}
export function useVirtualizerItem(options: VirtualizerItemOptions): {
    updateSize: () => void;
};
interface ScrollViewProps extends HTMLAttributes<HTMLElement> {
    contentSize: Size;
    onVisibleRectChange: (rect: Rect) => void;
    children?: ReactNode;
    innerStyle?: CSSProperties;
    onScrollStart?: () => void;
    onScrollEnd?: () => void;
    scrollDirection?: 'horizontal' | 'vertical' | 'both';
}
export const ScrollView: React.ForwardRefExoticComponent<ScrollViewProps & React.RefAttributes<HTMLDivElement | null>>;
interface ScrollViewAria {
    isScrolling: boolean;
    scrollViewProps: HTMLAttributes<HTMLElement>;
    contentProps: HTMLAttributes<HTMLElement>;
}
export function useScrollView(props: ScrollViewProps, ref: _RefObject1<HTMLElement | null>): ScrollViewAria;
interface VirtualizerItemProps extends Omit<VirtualizerItemOptions, 'ref'> {
    layoutInfo: LayoutInfo;
    parent?: LayoutInfo | null;
    style?: CSSProperties;
    className?: string;
    children: ReactNode;
}
export function VirtualizerItem(props: VirtualizerItemProps): JSX.Element;
export function layoutInfoToStyle(layoutInfo: LayoutInfo, dir: Direction, parent?: LayoutInfo | null): CSSProperties;
type RenderWrapper<T extends object, V> = (parent: ReusableView<T, V> | null, reusableView: ReusableView<T, V>, children: ReusableView<T, V>[], renderChildren: (views: ReusableView<T, V>[]) => ReactElement[]) => ReactElement | null;
interface VirtualizerProps<T extends object, V, O> extends Omit<HTMLAttributes<HTMLElement>, 'children'> {
    children: (type: string, content: T) => V;
    renderWrapper?: RenderWrapper<T, V>;
    layout: Layout<T, O>;
    collection: Collection<T>;
    persistedKeys?: Set<Key> | null;
    scrollDirection?: 'horizontal' | 'vertical' | 'both';
    isLoading?: boolean;
    onLoadMore?: () => void;
    layoutOptions?: O;
}
export const Virtualizer: <T extends object, V, O>(props: VirtualizerProps<T, V, O> & {
    ref?: RefObject<HTMLDivElement | null>;
}) => ReactElement;

//# sourceMappingURL=types.d.ts.map
