{"mappings":"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","sources":["packages/@react-stately/layout/src/ListLayout.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DropTarget, DropTargetDelegate, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {getChildNodes} from '@react-stately/collections';\nimport {InvalidationContext, Layout, LayoutInfo, Rect, Size} from '@react-stately/virtualizer';\n\nexport interface ListLayoutOptions {\n  /**\n   * The fixed height of a row in px.\n   * @default 48\n   */\n  rowHeight?: number,\n  /** The estimated height of a row, when row heights are variable. */\n  estimatedRowHeight?: number,\n  /**\n   * The fixed height of a section header in px.\n   * @default 48\n   */\n  headingHeight?: number,\n  /** The estimated height of a section header, when the height is variable. */\n  estimatedHeadingHeight?: number,\n  /**\n   * The fixed height of a loader element in px. This loader is specifically for\n   * \"load more\" elements rendered when loading more rows at the root level or inside nested row/sections.\n   * @default 48\n   */\n  loaderHeight?: number,\n  /**\n   * The thickness of the drop indicator.\n   * @default 2\n   */\n  dropIndicatorThickness?: number,\n  /**\n   * The gap between items.\n   * @default 0\n   */\n  gap?: number,\n  /**\n   * The padding around the list.\n   * @default 0\n   */\n  padding?: number\n}\n\n// A wrapper around LayoutInfo that supports hierarchy\nexport interface LayoutNode {\n  node?: Node<unknown>,\n  layoutInfo: LayoutInfo,\n  children?: LayoutNode[],\n  validRect: Rect,\n  index?: number\n}\n\nconst DEFAULT_HEIGHT = 48;\n\n/**\n * ListLayout is a virtualizer Layout implementation\n * that arranges its items in a vertical stack. It supports both fixed\n * and variable height items.\n */\nexport class ListLayout<T, O extends ListLayoutOptions = ListLayoutOptions> extends Layout<Node<T>, O> implements DropTargetDelegate {\n  protected rowHeight: number | null;\n  protected estimatedRowHeight: number | null;\n  protected headingHeight: number | null;\n  protected estimatedHeadingHeight: number | null;\n  protected loaderHeight: number | null;\n  protected dropIndicatorThickness: number;\n  protected gap: number;\n  protected padding: number;\n  protected layoutNodes: Map<Key, LayoutNode>;\n  protected contentSize: Size;\n  protected lastCollection: Collection<Node<T>> | null;\n  protected rootNodes: LayoutNode[];\n  private invalidateEverything: boolean;\n  /** The rectangle containing currently valid layout infos. */\n  protected validRect: Rect;\n  /** The rectangle of requested layout infos so far. */\n  protected requestedRect: Rect;\n\n  /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */\n  constructor(options: ListLayoutOptions = {}) {\n    super();\n    this.rowHeight = options.rowHeight ?? null;\n    this.estimatedRowHeight = options.estimatedRowHeight ?? null;\n    this.headingHeight = options.headingHeight ?? null;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight ?? null;\n    this.loaderHeight = options.loaderHeight ?? null;\n    this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n    this.gap = options.gap || 0;\n    this.padding = options.padding || 0;\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastCollection = null;\n    this.invalidateEverything = false;\n    this.validRect = new Rect();\n    this.requestedRect = new Rect();\n    this.contentSize = new Size();\n  }\n\n  // Backward compatibility for subclassing.\n  protected get collection(): Collection<Node<T>> {\n    return this.virtualizer!.collection;\n  }\n\n  getLayoutInfo(key: Key): LayoutInfo | null {\n    this.ensureLayoutInfo(key);\n    return this.layoutNodes.get(key)?.layoutInfo || null;\n  }\n\n  getVisibleLayoutInfos(rect: Rect): LayoutInfo[] {\n    // Adjust rect to keep number of visible rows consistent.\n    // (only if height > 1 for getDropTargetFromPoint)\n    if (rect.height > 1) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight ?? DEFAULT_HEIGHT) + this.gap;\n      rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n      rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n    }\n\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    this.layoutIfNeeded(rect);\n\n    let res: LayoutInfo[] = [];\n\n    let addNodes = (nodes: LayoutNode[]) => {\n      for (let node of nodes) {\n        if (this.isVisible(node, rect)) {\n          res.push(node.layoutInfo);\n\n          if (node.children) {\n            addNodes(node.children);\n          }\n        }\n      }\n    };\n\n    addNodes(this.rootNodes);\n    return res;\n  }\n\n  protected layoutIfNeeded(rect: Rect): void {\n    if (!this.lastCollection) {\n      return;\n    }\n\n    if (!this.requestedRect.containsRect(rect)) {\n      this.requestedRect = this.requestedRect.union(rect);\n      this.rootNodes = this.buildCollection();\n    }\n\n    // Ensure all of the persisted keys are available.\n    for (let key of this.virtualizer!.persistedKeys) {\n      if (this.ensureLayoutInfo(key)) {\n        return;\n      }\n    }\n  }\n\n  private ensureLayoutInfo(key: Key) {\n    // If the layout info wasn't found, it might be outside the bounds of the area that we've\n    // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n    // Compute the full layout and try again.\n    if (!this.layoutNodes.has(key) && this.requestedRect.area < this.contentSize.area && this.lastCollection) {\n      this.requestedRect = new Rect(0, 0, Infinity, Infinity);\n      this.rootNodes = this.buildCollection();\n      this.requestedRect = new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n      return true;\n    }\n\n    return false;\n  }\n\n  protected isVisible(node: LayoutNode, rect: Rect): boolean {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || node.layoutInfo.type === 'header' || node.layoutInfo.type === 'loader' || this.virtualizer!.isPersistedKey(node.layoutInfo.key);\n  }\n\n  protected shouldInvalidateEverything(invalidationContext: InvalidationContext<O>): boolean {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    // Also invalidate if fixed sizes/gaps change.\n    let options = invalidationContext.layoutOptions;\n    return invalidationContext.sizeChanged\n      || this.rowHeight !== (options?.rowHeight ?? this.rowHeight)\n      || this.headingHeight !== (options?.headingHeight ?? this.headingHeight)\n      || this.loaderHeight !== (options?.loaderHeight ?? this.loaderHeight)\n      || this.gap !== (options?.gap ?? this.gap)\n      || this.padding !== (options?.padding ?? this.padding);\n  }\n\n  shouldInvalidateLayoutOptions(newOptions: O, oldOptions: O): boolean {\n    return newOptions.rowHeight !== oldOptions.rowHeight\n      || newOptions.estimatedRowHeight !== oldOptions.estimatedRowHeight\n      || newOptions.headingHeight !== oldOptions.headingHeight\n      || newOptions.estimatedHeadingHeight !== oldOptions.estimatedHeadingHeight\n      || newOptions.loaderHeight !== oldOptions.loaderHeight\n      || newOptions.dropIndicatorThickness !== oldOptions.dropIndicatorThickness\n      || newOptions.gap !== oldOptions.gap\n      || newOptions.padding !== oldOptions.padding;\n  }\n\n  update(invalidationContext: InvalidationContext<O>): void {\n    let collection = this.virtualizer!.collection;\n\n    // Reset valid rect if we will have to invalidate everything.\n    // Otherwise we can reuse cached layout infos outside the current visible rect.\n    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n    if (this.invalidateEverything) {\n      this.requestedRect = this.virtualizer!.visibleRect.copy();\n      this.layoutNodes.clear();\n    }\n\n    let options = invalidationContext.layoutOptions;\n    this.rowHeight = options?.rowHeight ?? this.rowHeight;\n    this.estimatedRowHeight = options?.estimatedRowHeight ?? this.estimatedRowHeight;\n    this.headingHeight = options?.headingHeight ?? this.headingHeight;\n    this.estimatedHeadingHeight = options?.estimatedHeadingHeight ?? this.estimatedHeadingHeight;\n    this.loaderHeight = options?.loaderHeight ?? this.loaderHeight;\n    this.dropIndicatorThickness = options?.dropIndicatorThickness ?? this.dropIndicatorThickness;\n    this.gap = options?.gap ?? this.gap;\n    this.padding = options?.padding ?? this.padding;\n\n    this.rootNodes = this.buildCollection();\n\n    // Remove deleted layout nodes\n    if (this.lastCollection && collection !== this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) {\n        if (!collection.getItem(key)) {\n          let layoutNode = this.layoutNodes.get(key);\n          if (layoutNode) {\n            this.layoutNodes.delete(key);\n          }\n        }\n      }\n    }\n\n    this.lastCollection = collection;\n    this.invalidateEverything = false;\n    this.validRect = this.requestedRect.copy();\n  }\n\n  protected buildCollection(y: number = this.padding): LayoutNode[] {\n    let collection = this.virtualizer!.collection;\n    let collectionNodes = [...collection];\n    let loaderNodes = collectionNodes.filter(node => node.type === 'loader');\n    let nodes: LayoutNode[] = [];\n    let isEmptyOrLoading = collection?.size === 0;\n    if (isEmptyOrLoading) {\n      y = 0;\n    }\n\n    for (let node of collectionNodes) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight ?? DEFAULT_HEIGHT) + this.gap;\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (node.type === 'item' && y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(node, this.padding, y, null);\n      y = layoutNode.layoutInfo.rect.maxY + this.gap;\n      nodes.push(layoutNode);\n      if (node.type === 'loader') {\n        let index = loaderNodes.indexOf(node);\n        loaderNodes.splice(index, 1);\n      }\n\n      // Build each loader that exists in the collection that is outside the visible rect so that they are persisted\n      // at the proper estimated location. If the node.type is \"section\" then we don't do this shortcut since we have to\n      // build the sections to see how tall they are.\n      if ((node.type === 'item' || node.type === 'loader') && y > this.requestedRect.maxY) {\n        let lastProcessedIndex = collectionNodes.indexOf(node);\n        for (let loaderNode of loaderNodes) {\n          let loaderNodeIndex = collectionNodes.indexOf(loaderNode);\n          // Subtract by an additional 1 since we've already added the current item's height to y\n          y += (loaderNodeIndex - lastProcessedIndex - 1) * rowHeight;\n          let loader = this.buildChild(loaderNode, this.padding, y, null);\n          nodes.push(loader);\n          y = loader.layoutInfo.rect.maxY;\n          lastProcessedIndex = loaderNodeIndex;\n        }\n\n        // Account for the rest of the items after the last loader spinner, subtract by 1 since we've processed the current node's height already\n        y += (collectionNodes.length - lastProcessedIndex - 1) * rowHeight;\n        break;\n      }\n    }\n\n    y -= this.gap;\n    y += isEmptyOrLoading ? 0 : this.padding;\n    this.contentSize = new Size(this.virtualizer!.visibleRect.width, y);\n    return nodes;\n  }\n\n  protected isValid(node: Node<T>, y: number): boolean {\n    let cached = this.layoutNodes.get(node.key);\n    return (\n      !this.invalidateEverything &&\n      !!cached &&\n      cached.node === node &&\n      y === cached.layoutInfo.rect.y &&\n      cached.layoutInfo.rect.intersects(this.validRect) &&\n      cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.requestedRect))\n    );\n  }\n\n  protected buildChild(node: Node<T>, x: number, y: number, parentKey: Key | null): LayoutNode {\n    if (this.isValid(node, y)) {\n      return this.layoutNodes.get(node.key)!;\n    }\n\n    let layoutNode = this.buildNode(node, x, y);\n\n    layoutNode.layoutInfo.parentKey = parentKey ?? null;\n    layoutNode.layoutInfo.allowOverflow = true;\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n\n  protected buildNode(node: Node<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n      case 'item':\n        return this.buildItem(node, x, y);\n      case 'header':\n        return this.buildSectionHeader(node, x, y);\n      case 'loader':\n        return this.buildLoader(node, x, y);\n      case 'separator':\n        return this.buildItem(node, x, y);\n      default:\n        throw new Error('Unsupported node type: ' + node.type);\n    }\n  }\n\n  protected buildLoader(node: Node<T>, x: number, y: number): LayoutNode {\n    let rect = new Rect(x, y, this.padding, 0);\n    let layoutInfo = new LayoutInfo('loader', node.key, rect);\n    rect.width = this.virtualizer!.contentSize.width - this.padding - x;\n    // Note that if the user provides isLoading to their sentinel during a case where they only want to render the emptyState, this will reserve\n    // room for the loader alongside rendering the emptyState\n    rect.height = node.props.isLoading ? this.loaderHeight ?? this.rowHeight ?? this.estimatedRowHeight ?? DEFAULT_HEIGHT : 0;\n\n    return {\n      layoutInfo,\n      validRect: rect.intersection(this.requestedRect)\n    };\n  }\n\n  protected buildSection(node: Node<T>, x: number, y: number): LayoutNode {\n    let collection = this.virtualizer!.collection;\n    let width = this.virtualizer!.visibleRect.width - this.padding;\n    let rect = new Rect(x, y, width - x, 0);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n\n    let startY = y;\n    let skipped = 0;\n    let children: LayoutNode[] = [];\n    for (let child of getChildNodes(node, collection)) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight ?? DEFAULT_HEIGHT) + this.gap;\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n      y = layoutNode.layoutInfo.rect.maxY + this.gap;\n      children.push(layoutNode);\n\n      if (y > this.requestedRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += ([...getChildNodes(node, collection)].length - (children.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n\n    y -= this.gap;\n    rect.height = y - startY;\n\n    return {\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect.intersection(this.requestedRect),\n      node\n    };\n  }\n\n  protected buildSectionHeader(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer!.visibleRect.width - this.padding;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      let previousLayoutInfo = previousLayoutNode?.layoutInfo;\n      if (previousLayoutInfo) {\n        let curNode = this.virtualizer!.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutInfo.rect.height;\n        isEstimated = width !== previousLayoutInfo.rect.width || curNode !== lastNode || previousLayoutInfo.estimatedSize;\n      } else {\n        rectHeight = (node.rendered ? this.estimatedHeadingHeight : 0);\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let headerRect = new Rect(x, y, width - x, rectHeight);\n    let header = new LayoutInfo('header', node.key, headerRect);\n    header.estimatedSize = isEstimated;\n    return {\n      layoutInfo: header,\n      children: [],\n      validRect: header.rect.intersection(this.requestedRect),\n      node\n    };\n  }\n\n  protected buildItem(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer!.visibleRect.width - this.padding - x;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== previousLayoutNode.layoutInfo.rect.width || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let rect = new Rect(x, y, width, rectHeight);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo,\n      children: [],\n      validRect: layoutInfo.rect,\n      node\n    };\n  }\n\n  updateItemSize(key: Key, size: Size): boolean {\n    let layoutNode = this.layoutNodes.get(key);\n    // If no layoutInfo, item has been deleted/removed.\n    if (!layoutNode) {\n      return false;\n    }\n\n    let collection = this.virtualizer!.collection;\n    let layoutInfo = layoutNode.layoutInfo;\n    layoutInfo.estimatedSize = false;\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      layoutNode.layoutInfo = newLayoutInfo;\n\n      // Items after this layoutInfo will need to be repositioned to account for the new height.\n      // Adjust the validRect so that only items above remain valid.\n      this.validRect.height = Math.min(this.validRect.height, layoutInfo.rect.y - this.validRect.y);\n\n      // The requestedRect also needs to be adjusted to account for the height difference.\n      this.requestedRect.height += newLayoutInfo.rect.height - layoutInfo.rect.height;\n\n      // Invalidate layout for this layout node and all parents\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n\n      let node = layoutInfo.parentKey != null ? collection.getItem(layoutInfo.parentKey) : null;\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = node.parentKey != null ? collection.getItem(node.parentKey) : null;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private updateLayoutNode(key: Key, oldLayoutInfo: LayoutInfo, newLayoutInfo: LayoutInfo) {\n    let n = this.layoutNodes.get(key);\n    if (n) {\n      // Invalidate by intersecting the validRect of this node with the overall validRect.\n      n.validRect = n.validRect.intersection(this.validRect);\n\n      // Replace layout info in LayoutNode\n      if (n.layoutInfo === oldLayoutInfo) {\n        n.layoutInfo = newLayoutInfo;\n      }\n    }\n  }\n\n  getContentSize(): Size {\n    return this.contentSize;\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget | null {\n    x += this.virtualizer!.visibleRect.x;\n    y += this.virtualizer!.visibleRect.y;\n\n    // Find the closest item within on either side of the point using the gap width.\n    let searchRect = new Rect(x, Math.max(0, y - this.gap), 1, Math.max(1, this.gap * 2));\n    let candidates = this.getVisibleLayoutInfos(searchRect);\n    let key: Key | null = null;\n    let minDistance = Infinity;\n    for (let candidate of candidates) {\n      // Ignore items outside the search rect, e.g. persisted keys.\n      if (!candidate.rect.intersects(searchRect)) {\n        continue;\n      }\n\n      let yDist = Math.abs(candidate.rect.y - y);\n      let maxYDist = Math.abs(candidate.rect.maxY - y);\n      let dist = Math.min(yDist, maxYDist);\n      if (dist < minDistance) {\n        minDistance = dist;\n        key = candidate.key;\n      }\n    }\n\n    if (key == null || this.virtualizer!.collection.size === 0) {\n      return {type: 'root'};\n    }\n\n    let layoutInfo = this.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return null;\n    }\n\n    let rect = layoutInfo.rect;\n    let target: DropTarget = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    } else if (y <= rect.y + 10 && isValidDropTarget({...target, dropPosition: 'before'})) {\n      target.dropPosition = 'before';\n    } else if (y >= rect.maxY - 10 && isValidDropTarget({...target, dropPosition: 'after'})) {\n      target.dropPosition = 'after';\n    }\n\n    return target;\n  }\n\n  getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo {\n    let layoutInfo = this.getLayoutInfo(target.key)!;\n    let rect: Rect;\n    if (target.dropPosition === 'before') {\n      rect = new Rect(layoutInfo.rect.x, Math.max(0, layoutInfo.rect.y - this.dropIndicatorThickness / 2), layoutInfo.rect.width, this.dropIndicatorThickness);\n    } else if (target.dropPosition === 'after') {\n      // Render after last visible descendant of the drop target.\n      let targetNode = this.collection.getItem(target.key);\n      if (targetNode) {\n        let targetLevel = targetNode.level ?? 0;\n        let currentKey = this.collection.getKeyAfter(target.key);\n\n        while (currentKey != null) {\n          let node = this.collection.getItem(currentKey);\n          if (!node || node.level <= targetLevel) {\n            break;\n          }\n\n          layoutInfo = this.getLayoutInfo(currentKey) || layoutInfo;\n          currentKey = this.collection.getKeyAfter(currentKey);\n        }\n      }\n      rect = new Rect(layoutInfo.rect.x, layoutInfo.rect.maxY - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n    } else {\n      rect = layoutInfo.rect;\n    }\n\n    return new LayoutInfo('dropIndicator', target.key + ':' + target.dropPosition, rect);\n  }\n}\n"],"names":[],"version":3,"file":"ListLayout.module.js.map"}