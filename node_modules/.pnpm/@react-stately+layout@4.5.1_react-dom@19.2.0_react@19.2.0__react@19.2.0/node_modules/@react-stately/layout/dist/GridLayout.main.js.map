{"mappings":"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","sources":["packages/@react-stately/layout/src/GridLayout.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DropTarget, DropTargetDelegate, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {InvalidationContext, Layout, LayoutInfo, Rect, Size} from '@react-stately/virtualizer';\n\nexport interface GridLayoutOptions {\n  /**\n   * The minimum item size.\n   * @default 200 x 200\n   */\n  minItemSize?: Size,\n  /**\n   * The maximum item size.\n   * @default Infinity\n   */\n  maxItemSize?: Size,\n  /**\n   * Whether to preserve the aspect ratio of the `minItemSize`.\n   * By default, grid rows may have variable heights. When `preserveAspectRatio`\n   * is true, all rows will have equal heights.\n   * @default false\n   */\n  preserveAspectRatio?: boolean,\n  /**\n   * The minimum space required between items.\n   * @default 18 x 18\n   */\n  minSpace?: Size,\n  /**\n   * The maximum allowed horizontal space between items.\n   * @default Infinity\n   */\n  maxHorizontalSpace?: number,\n  /**\n   * The maximum number of columns.\n   * @default Infinity\n   */\n  maxColumns?: number,\n  /**\n   * The thickness of the drop indicator.\n   * @default 2\n   */\n  dropIndicatorThickness?: number\n}\n\nconst DEFAULT_OPTIONS = {\n  minItemSize: new Size(200, 200),\n  maxItemSize: new Size(Infinity, Infinity),\n  preserveAspectRatio: false,\n  minSpace: new Size(18, 18),\n  maxSpace: Infinity,\n  maxColumns: Infinity,\n  dropIndicatorThickness: 2\n};\n\n/**\n * GridLayout is a virtualizer Layout implementation\n * that arranges its items in a grid.\n * The items are sized between a minimum and maximum size\n * depending on the width of the container.\n */\nexport class GridLayout<T, O extends GridLayoutOptions = GridLayoutOptions> extends Layout<Node<T>, O> implements DropTargetDelegate {\n  protected gap: Size = DEFAULT_OPTIONS.minSpace;\n  protected dropIndicatorThickness = 2;\n  protected numColumns: number = 0;\n  private contentSize: Size = new Size();\n  private layoutInfos: Map<Key, LayoutInfo> = new Map();\n  private margin: number = 0;\n\n  shouldInvalidateLayoutOptions(newOptions: O, oldOptions: O): boolean {\n    return newOptions.maxColumns !== oldOptions.maxColumns\n      || newOptions.dropIndicatorThickness !== oldOptions.dropIndicatorThickness\n      || newOptions.preserveAspectRatio !== oldOptions.preserveAspectRatio\n      || (!(newOptions.minItemSize || DEFAULT_OPTIONS.minItemSize).equals(oldOptions.minItemSize || DEFAULT_OPTIONS.minItemSize))\n      || (!(newOptions.maxItemSize || DEFAULT_OPTIONS.maxItemSize).equals(oldOptions.maxItemSize || DEFAULT_OPTIONS.maxItemSize))\n      || (!(newOptions.minSpace || DEFAULT_OPTIONS.minSpace).equals(oldOptions.minSpace || DEFAULT_OPTIONS.minSpace))\n      || newOptions.maxHorizontalSpace !== oldOptions.maxHorizontalSpace;\n  }\n\n  update(invalidationContext: InvalidationContext<O>): void {\n    let {\n      minItemSize = DEFAULT_OPTIONS.minItemSize,\n      maxItemSize = DEFAULT_OPTIONS.maxItemSize,\n      preserveAspectRatio = DEFAULT_OPTIONS.preserveAspectRatio,\n      minSpace = DEFAULT_OPTIONS.minSpace,\n      maxHorizontalSpace = DEFAULT_OPTIONS.maxSpace,\n      maxColumns = DEFAULT_OPTIONS.maxColumns,\n      dropIndicatorThickness = DEFAULT_OPTIONS.dropIndicatorThickness\n    } = invalidationContext.layoutOptions || {};\n    this.dropIndicatorThickness = dropIndicatorThickness;\n\n    let visibleWidth = this.virtualizer!.visibleRect.width;\n\n    // The max item width is always the entire viewport.\n    // If the max item height is infinity, scale in proportion to the max width.\n    let maxItemWidth = Math.min(maxItemSize.width, visibleWidth);\n    let maxItemHeight = Number.isFinite(maxItemSize.height)\n      ? maxItemSize.height\n      : Math.floor((minItemSize.height / minItemSize.width) * maxItemWidth);\n\n    // Compute the number of rows and columns needed to display the content\n    let columns = Math.floor(visibleWidth / (minItemSize.width + minSpace.width));\n    let numColumns = Math.max(1, Math.min(maxColumns, columns));\n    this.numColumns = numColumns;\n\n    // Compute the available width (minus the space between items)\n    let width = visibleWidth - (minSpace.width * Math.max(0, numColumns));\n\n    // Compute the item width based on the space available\n    let itemWidth = Math.floor(width / numColumns);\n    itemWidth = Math.max(minItemSize.width, Math.min(maxItemWidth, itemWidth));\n\n    // Compute the item height, which is proportional to the item width\n    let t = ((itemWidth - minItemSize.width) / Math.max(1, maxItemWidth - minItemSize.width));\n    let itemHeight = minItemSize.height + Math.floor((maxItemHeight - minItemSize.height) * t);\n    itemHeight = Math.max(minItemSize.height, Math.min(maxItemHeight, itemHeight));\n\n    // Compute the horizontal spacing, content height and horizontal margin\n    let horizontalSpacing = Math.min(Math.max(maxHorizontalSpace, minSpace.width), Math.floor((visibleWidth - numColumns * itemWidth) / (numColumns + 1)));\n    this.gap = new Size(horizontalSpacing, minSpace.height);\n    this.margin = Math.floor((visibleWidth - numColumns * itemWidth - horizontalSpacing * (numColumns + 1)) / 2);\n\n    // If there is a skeleton loader within the last 2 items in the collection, increment the collection size\n    // so that an additional row is added for the skeletons.\n    let collection = this.virtualizer!.collection;\n    let collectionSize = collection.size;\n    let lastKey = collection.getLastKey();\n    for (let i = 0; i < 2 && lastKey != null; i++) {\n      let item = collection.getItem(lastKey);\n      if (item?.type === 'skeleton') {\n        collectionSize++;\n        break;\n      }\n      lastKey = collection.getKeyBefore(lastKey);\n    }\n\n    let rows = Math.ceil(collectionSize / numColumns);\n    let iterator = collection[Symbol.iterator]();\n    let y = rows > 0 ? minSpace.height : 0;\n    let newLayoutInfos = new Map();\n    let skeleton: Node<T> | null = null;\n    let skeletonCount = 0;\n    for (let row = 0; row < rows; row++) {\n      let maxHeight = 0;\n      let rowLayoutInfos: LayoutInfo[] = [];\n      for (let col = 0; col < numColumns; col++) {\n        // Repeat skeleton until the end of the current row.\n        let node = skeleton || iterator.next().value;\n        if (!node) {\n          break;\n        }\n\n        // We will add the loader after the skeletons so skip here\n        if (node.type === 'loader') {\n          continue;\n        }\n\n        if (node.type === 'skeleton') {\n          skeleton = node;\n        }\n\n        let key = skeleton ? `${skeleton.key}-${skeletonCount++}` : node.key;\n        let oldLayoutInfo = this.layoutInfos.get(key);\n        let content = node;\n        if (skeleton) {\n          content = oldLayoutInfo && oldLayoutInfo.content.key === key ? oldLayoutInfo.content : {...skeleton, key};\n        }\n        let x = horizontalSpacing + col * (itemWidth + horizontalSpacing) + this.margin;\n        let height = itemHeight;\n        let estimatedSize = !preserveAspectRatio;\n        if (oldLayoutInfo && estimatedSize) {\n          height = oldLayoutInfo.rect.height;\n          estimatedSize = invalidationContext.layoutOptionsChanged || invalidationContext.sizeChanged || oldLayoutInfo.estimatedSize || (oldLayoutInfo.content !== content);\n        }\n\n        let rect = new Rect(x, y, itemWidth, height);\n        let layoutInfo = new LayoutInfo(node.type, key, rect);\n        layoutInfo.estimatedSize = estimatedSize;\n        layoutInfo.allowOverflow = true;\n        layoutInfo.content = content;\n        newLayoutInfos.set(key, layoutInfo);\n        rowLayoutInfos.push(layoutInfo);\n\n        maxHeight = Math.max(maxHeight, layoutInfo.rect.height);\n      }\n\n      for (let layoutInfo of rowLayoutInfos) {\n        layoutInfo.rect.height = maxHeight;\n      }\n\n      y += maxHeight + minSpace.height;\n\n      // Keep adding skeleton rows until we fill the viewport\n      if (skeleton && row === rows - 1 && y < this.virtualizer!.visibleRect.height) {\n        rows++;\n      }\n    }\n\n    // Always add the loader sentinel if present in the collection so we can make sure it is never virtualized out.\n    let lastNode = collection.getItem(collection.getLastKey()!);\n    if (lastNode?.type === 'loader') {\n      let rect = new Rect(horizontalSpacing, y, itemWidth, 0);\n      let layoutInfo = new LayoutInfo('loader', lastNode.key, rect);\n      newLayoutInfos.set(lastNode.key, layoutInfo);\n    }\n\n    this.layoutInfos = newLayoutInfos;\n    this.contentSize = new Size(this.virtualizer!.visibleRect.width, y);\n  }\n\n  getLayoutInfo(key: Key): LayoutInfo | null {\n    return this.layoutInfos.get(key) || null;\n  }\n\n  getContentSize(): Size {\n    return this.contentSize;\n  }\n\n  getVisibleLayoutInfos(rect: Rect): LayoutInfo[] {\n    let layoutInfos: LayoutInfo[] = [];\n    for (let layoutInfo of this.layoutInfos.values()) {\n      if (layoutInfo.rect.intersects(rect) || this.virtualizer!.isPersistedKey(layoutInfo.key) || layoutInfo.type === 'loader') {\n        layoutInfos.push(layoutInfo);\n      }\n    }\n    return layoutInfos;\n  }\n\n  updateItemSize(key: Key, size: Size): boolean {\n    let layoutInfo = this.layoutInfos.get(key);\n    if (!size || !layoutInfo) {\n      return false;\n    }\n\n    if (size.height !== layoutInfo.rect.height) {\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      newLayoutInfo.estimatedSize = false;\n      this.layoutInfos.set(key, newLayoutInfo);\n      return true;\n    }\n\n    return false;\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    if (this.layoutInfos.size === 0) {\n      return {type: 'root'};\n    }\n\n    x += this.virtualizer!.visibleRect.x;\n    y += this.virtualizer!.visibleRect.y;\n\n    // Find the closest item within on either side of the point using the gap width.\n    let key: Key | null = null;\n    if (this.numColumns === 1) {\n      let searchRect = new Rect(x, Math.max(0, y - this.gap.height), 1, Math.max(1, this.gap.height * 2));\n      let candidates = this.getVisibleLayoutInfos(searchRect);\n      let minDistance = Infinity;\n      for (let candidate of candidates) {\n        // Ignore items outside the search rect, e.g. persisted keys.\n        if (!candidate.rect.intersects(searchRect)) {\n          continue;\n        }\n\n        let yDist = Math.abs(candidate.rect.y - y);\n        let maxYDist = Math.abs(candidate.rect.maxY - y);\n        let dist = Math.min(yDist, maxYDist);\n        if (dist < minDistance) {\n          minDistance = dist;\n          key = candidate.key;\n        }\n      }\n    } else {\n      let searchRect = new Rect(Math.max(0, x - this.gap.width), y, this.gap.width * 2, 1);\n      let candidates = this.getVisibleLayoutInfos(searchRect);\n      let minDistance = Infinity;\n      for (let candidate of candidates) {\n        // Ignore items outside the search rect, e.g. persisted keys.\n        if (!candidate.rect.intersects(searchRect)) {\n          continue;\n        }\n\n        let xDist = Math.abs(candidate.rect.x - x);\n        let maxXDist = Math.abs(candidate.rect.maxX - x);\n        let dist = Math.min(xDist, maxXDist);\n        if (dist < minDistance) {\n          minDistance = dist;\n          key = candidate.key;\n        }\n      }\n    }\n\n    let layoutInfo = key != null ? this.getLayoutInfo(key) : null;\n    if (!layoutInfo) {\n      return {type: 'root'};\n    }\n\n    let target: DropTarget =  {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    let pos = this.numColumns === 1 ? y : x;\n    let layoutInfoPos = this.numColumns === 1 ? layoutInfo.rect.y : layoutInfo.rect.x;\n    let size = this.numColumns === 1 ? layoutInfo.rect.height : layoutInfo.rect.width;\n    if (isValidDropTarget(target)) {\n      // If dropping on the item is accepted, try the before/after positions\n      // if within 5px of the start or end of the item.\n      if (pos < layoutInfoPos + 5) {\n        target.dropPosition = 'before';\n      } else if (pos > layoutInfoPos + size - 5) {\n        target.dropPosition = 'after';\n      }\n    } else {\n      // If dropping on the item isn't accepted, try the target before or after depending on the position.\n      let mid = layoutInfoPos + size / 2;\n      if (pos <= mid && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (pos >= mid && isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    }\n\n    return target;\n  }\n\n  getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo {\n    let layoutInfo = this.getLayoutInfo(target.key)!;\n    let rect: Rect;\n    if (this.numColumns === 1) {\n      // Flip from vertical to horizontal if only one column is visible.\n      rect = new Rect(\n        layoutInfo.rect.x,\n        target.dropPosition === 'before'\n          ? layoutInfo.rect.y - this.gap.height / 2 - this.dropIndicatorThickness / 2\n          : layoutInfo.rect.maxY + this.gap.height / 2 - this.dropIndicatorThickness / 2,\n        layoutInfo.rect.width,\n        this.dropIndicatorThickness\n      );\n    } else {\n      rect = new Rect(\n        target.dropPosition === 'before'\n          ? layoutInfo.rect.x - this.gap.width / 2 - this.dropIndicatorThickness / 2\n          : layoutInfo.rect.maxX + this.gap.width / 2 - this.dropIndicatorThickness / 2,\n        layoutInfo.rect.y,\n        this.dropIndicatorThickness,\n        layoutInfo.rect.height\n      );\n    }\n\n    return new LayoutInfo('dropIndicator', target.key + ':' + target.dropPosition, rect);\n  }\n}\n"],"names":[],"version":3,"file":"GridLayout.main.js.map"}