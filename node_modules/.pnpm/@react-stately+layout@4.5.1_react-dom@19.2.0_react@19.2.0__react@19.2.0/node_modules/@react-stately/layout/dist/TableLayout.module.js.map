{"mappings":"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","sources":["packages/@react-stately/layout/src/TableLayout.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DropTarget, ItemDropTarget, Key} from '@react-types/shared';\nimport {getChildNodes, getLastItem} from '@react-stately/collections';\nimport {GridNode} from '@react-types/grid';\nimport {InvalidationContext, LayoutInfo, Point, Rect, Size} from '@react-stately/virtualizer';\nimport {LayoutNode, ListLayout, ListLayoutOptions} from './ListLayout';\nimport {TableCollection} from '@react-types/table';\nimport {TableColumnLayout} from '@react-stately/table';\n\nexport interface TableLayoutProps extends ListLayoutOptions {\n  columnWidths?: Map<Key, number>\n}\n\nconst DEFAULT_ROW_HEIGHT = 48;\n\n/**\n * TableLayout is a virtualizer Layout implementation that arranges\n * items in rows and columns.\n */\nexport class TableLayout<T, O extends TableLayoutProps = TableLayoutProps> extends ListLayout<T, O> {\n  protected lastCollection: TableCollection<T> | null = null;\n  private columnWidths: Map<Key, number> = new Map();\n  private stickyColumnIndices: number[];\n  private lastPersistedKeys: Set<Key> | null = null;\n  private persistedIndices: Map<Key, number[]> = new Map();\n\n  constructor(options?: ListLayoutOptions) {\n    super(options);\n    this.stickyColumnIndices = [];\n  }\n\n  // Backward compatibility for subclassing.\n  protected get collection(): TableCollection<T> {\n    return this.virtualizer!.collection as TableCollection<T>;\n  }\n\n  private columnsChanged(newCollection: TableCollection<T>, oldCollection: TableCollection<T> | null) {\n    return !oldCollection ||\n      newCollection.columns !== oldCollection.columns &&\n      newCollection.columns.length !== oldCollection.columns.length ||\n      newCollection.columns.some((c, i) =>\n        c.key !== oldCollection.columns[i].key ||\n        c.props.width !== oldCollection.columns[i].props.width ||\n        c.props.minWidth !== oldCollection.columns[i].props.minWidth ||\n        c.props.maxWidth !== oldCollection.columns[i].props.maxWidth\n      );\n  }\n\n  shouldInvalidateLayoutOptions(newOptions: O, oldOptions: O): boolean {\n    return newOptions.columnWidths !== oldOptions.columnWidths\n      || super.shouldInvalidateLayoutOptions(newOptions, oldOptions);\n  }\n\n  update(invalidationContext: InvalidationContext<O>): void {\n    let newCollection = this.virtualizer!.collection as TableCollection<T>;\n\n    // If columnWidths were provided via layoutOptions, update those.\n    // Otherwise, calculate column widths ourselves.\n    if (invalidationContext.layoutOptions?.columnWidths) {\n      for (const [key, val] of invalidationContext.layoutOptions.columnWidths) {\n        if (this.columnWidths.get(key) !== val) {\n          this.columnWidths = invalidationContext.layoutOptions.columnWidths;\n          invalidationContext.sizeChanged = true;\n          break;\n        }\n      }\n    } else if (invalidationContext.sizeChanged || this.columnsChanged(newCollection, this.lastCollection)) {\n      let columnLayout = new TableColumnLayout({});\n      this.columnWidths = columnLayout.buildColumnWidths(this.virtualizer!.visibleRect.width - this.padding * 2, newCollection, new Map());\n      invalidationContext.sizeChanged = true;\n    }\n\n    super.update(invalidationContext);\n  }\n\n  protected buildCollection(): LayoutNode[] {\n    this.stickyColumnIndices = [];\n\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    if (collection.head?.key === -1) {\n      return [];\n    }\n\n    for (let column of collection.columns) {\n      // The selection cell and any other sticky columns always need to be visible.\n      // In addition, row headers need to be in the DOM for accessibility labeling.\n      if (this.isStickyColumn(column) || collection.rowHeaderColumnKeys.has(column.key)) {\n        this.stickyColumnIndices.push(column.index);\n      }\n    }\n\n    let header = this.buildTableHeader();\n    this.layoutNodes.set(header.layoutInfo.key, header);\n    let body = this.buildBody(header.layoutInfo.rect.maxY + this.gap);\n    this.lastPersistedKeys = null;\n\n    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n    this.contentSize = new Size(body.layoutInfo.rect.width + this.padding * 2, body.layoutInfo.rect.maxY + this.padding);\n    return [\n      header,\n      body\n    ];\n  }\n\n  protected buildTableHeader(): LayoutNode {\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    let rect = new Rect(this.padding, this.padding, 0, 0);\n    let layoutInfo = new LayoutInfo('header', collection.head?.key ?? 'header', rect);\n    layoutInfo.isSticky = true;\n    layoutInfo.zIndex = 1;\n\n    let y = this.padding;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    for (let headerRow of collection.headerRows) {\n      let layoutNode = this.buildChild(headerRow, this.padding, y, layoutInfo.key);\n      layoutNode.layoutInfo.parentKey = layoutInfo.key;\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      layoutNode.index = children.length;\n      children.push(layoutNode);\n    }\n\n    rect.width = width;\n    rect.height = y - this.padding;\n\n    return {\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect,\n      node: collection.head\n    };\n  }\n\n  protected buildHeaderRow(headerRow: GridNode<T>, x: number, y: number): LayoutNode {\n    let rect = new Rect(x, y, 0, 0);\n    let row = new LayoutInfo('headerrow', headerRow.key, rect);\n\n    let height = 0;\n    let columns: LayoutNode[] = [];\n    for (let cell of getChildNodes(headerRow, this.virtualizer!.collection)) {\n      let layoutNode = this.buildChild(cell, x, y, row.key);\n      layoutNode.layoutInfo.parentKey = row.key;\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      layoutNode.index = columns.length;\n      columns.push(layoutNode);\n    }\n    for (let [i, layout] of columns.entries()) {\n      layout.layoutInfo.zIndex = columns.length - i + 1;\n    }\n\n    this.setChildHeights(columns, height);\n\n    rect.height = height;\n    rect.width = x - rect.x;\n\n    return {\n      layoutInfo: row,\n      children: columns,\n      validRect: rect,\n      node: headerRow\n    };\n  }\n\n  private setChildHeights(children: LayoutNode[], height: number) {\n    for (let child of children) {\n      if (child.layoutInfo.rect.height !== height) {\n        // Need to copy the layout info before we mutate it.\n        child.layoutInfo = child.layoutInfo.copy();\n        child.layoutInfo.rect.height = height;\n      }\n    }\n  }\n\n  // used to get the column widths when rendering to the DOM\n  private getRenderedColumnWidth(node: GridNode<T>) {\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    let colSpan = node.colSpan ?? 1;\n    let colIndex = node.colIndex ?? node.index;\n    let width = 0;\n    for (let i = colIndex; i < colIndex + colSpan; i++) {\n      let column = collection.columns[i];\n      if (column?.key != null) {\n        width += this.columnWidths.get(column.key) ?? 0;\n      }\n    }\n\n    return width;\n  }\n\n  private getEstimatedHeight(node: GridNode<T>, width: number, height: number | null, estimatedHeight: number | null) {\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (height == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        height = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = node !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        height = estimatedHeight ?? DEFAULT_ROW_HEIGHT;\n        isEstimated = true;\n      }\n    }\n\n    return {height, isEstimated};\n  }\n\n  protected getEstimatedRowHeight(): number {\n    return this.rowHeight ?? this.estimatedRowHeight ?? DEFAULT_ROW_HEIGHT;\n  }\n\n  protected buildColumn(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getRenderedColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.headingHeight ?? this.rowHeight, this.estimatedHeadingHeight ?? this.estimatedRowHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = this.isStickyColumn(node);\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo,\n      children: [],\n      validRect: layoutInfo.rect,\n      node\n    };\n  }\n\n  // For subclasses.\n  // eslint-disable-next-line\n  protected isStickyColumn(node: GridNode<T>) {\n    return false;\n  }\n\n  protected buildBody(y: number): LayoutNode {\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    let rect = new Rect(this.padding, y, 0, 0);\n    let layoutInfo = new LayoutInfo('rowgroup', collection.body.key, rect);\n\n    let startY = y;\n    let skipped = 0;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    let rowHeight = this.getEstimatedRowHeight() + this.gap;\n    let childNodes = getChildNodes(collection.body, collection);\n    for (let node of childNodes) {\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(node, this.padding, y, layoutInfo.key);\n      layoutNode.layoutInfo.parentKey = layoutInfo.key;\n      layoutNode.index = children.length;\n      y = layoutNode.layoutInfo.rect.maxY + this.gap;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n\n      if (y > this.requestedRect.maxY) {\n        let rowsAfterRect = collection.size - (children.length + skipped);\n        let lastNode = getLastItem(childNodes);\n\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += rowsAfterRect * rowHeight;\n\n        // Always add the loader sentinel if present. This assumes the loader is the last row in the body,\n        // will need to refactor when handling multi section loading\n        if (lastNode?.type === 'loader' && children.at(-1)?.layoutInfo.type !== 'loader') {\n          let loader = this.buildChild(lastNode, this.padding, y, layoutInfo.key);\n          loader.layoutInfo.parentKey = layoutInfo.key;\n          loader.index = collection.size;\n          width = Math.max(width, loader.layoutInfo.rect.width);\n          children.push(loader);\n          y = loader.layoutInfo.rect.maxY;\n        }\n        break;\n      }\n    }\n\n    // Make sure that the table body gets a height if empty or performing initial load\n    let isEmptyOrLoading = collection?.size === 0;\n    if (isEmptyOrLoading) {\n      y = this.virtualizer!.visibleRect.maxY;\n    } else {\n      y -= this.gap;\n    }\n\n    rect.width = width;\n    rect.height = y - startY;\n\n    return {\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect.intersection(this.requestedRect),\n      node: collection.body\n    };\n  }\n\n  protected buildNode(node: GridNode<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'headerrow':\n        return this.buildHeaderRow(node, x, y);\n      case 'item':\n        return this.buildRow(node, x, y);\n      case 'column':\n      case 'placeholder':\n        return this.buildColumn(node, x, y);\n      case 'cell':\n        return this.buildCell(node, x, y);\n      case 'loader':\n        return this.buildLoader(node, x, y);\n      default:\n        throw new Error('Unknown node type ' + node.type);\n    }\n  }\n\n  protected buildRow(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let collection = this.virtualizer!.collection as TableCollection<T>;\n    let rect = new Rect(x, y, 0, 0);\n    let layoutInfo = new LayoutInfo('row', node.key, rect);\n\n    let children: LayoutNode[] = [];\n    let height = 0;\n    for (let child of getChildNodes(node, collection)) {\n      if (child.type === 'cell') {\n        if (x > this.requestedRect.maxX) {\n          // Adjust existing cached layoutInfo to ensure that it is out of view.\n          // This can happen due to column resizing.\n          let layoutNode = this.layoutNodes.get(child.key);\n          if (layoutNode) {\n            layoutNode.layoutInfo.rect.x = x;\n            x += layoutNode.layoutInfo.rect.width;\n          } else {\n            break;\n          }\n        } else {\n          let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n          x = layoutNode.layoutInfo.rect.maxX;\n          height = Math.max(height, layoutNode.layoutInfo.rect.height);\n          layoutNode.index = children.length;\n          children.push(layoutNode);\n        }\n      }\n    }\n\n    this.setChildHeights(children, height);\n\n    rect.width = this.layoutNodes.get(collection.head?.key ?? 'header')!.layoutInfo.rect.width;\n    rect.height = height;\n\n    return {\n      layoutInfo,\n      children,\n      validRect: rect.intersection(this.requestedRect),\n      node\n    };\n  }\n\n  protected buildCell(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getRenderedColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = this.isStickyColumn(node);\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo,\n      children: [],\n      validRect: rect,\n      node\n    };\n  }\n\n  getVisibleLayoutInfos(rect: Rect): LayoutInfo[] {\n    // Adjust rect to keep number of visible rows consistent.\n    // (only if height > 1 for getDropTargetFromPoint)\n    if (rect.height > 1) {\n      let rowHeight = this.getEstimatedRowHeight();\n      rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n      rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n    }\n\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    this.layoutIfNeeded(rect);\n\n    let res: LayoutInfo[] = [];\n\n    this.buildPersistedIndices();\n    for (let node of this.rootNodes) {\n      res.push(node.layoutInfo);\n      this.addVisibleLayoutInfos(res, node, rect);\n    }\n\n    return res;\n  }\n\n  private addVisibleLayoutInfos(res: LayoutInfo[], node: LayoutNode, rect: Rect) {\n    if (!node.children || node.children.length === 0) {\n      return;\n    }\n\n    switch (node.layoutInfo.type) {\n      case 'header': {\n        for (let child of node.children) {\n          res.push(child.layoutInfo);\n          this.addVisibleLayoutInfos(res, child, rect);\n        }\n        break;\n      }\n      case 'rowgroup': {\n        let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n        let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n\n        // Add persisted rows before the visible rows.\n        let persistedRowIndices = this.persistedIndices.get(node.layoutInfo.key);\n        let persistIndex = 0;\n        while (\n          persistedRowIndices &&\n          persistIndex < persistedRowIndices.length &&\n          persistedRowIndices[persistIndex] < firstVisibleRow\n        ) {\n          let idx = persistedRowIndices[persistIndex];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n          }\n          persistIndex++;\n        }\n\n        for (let i = firstVisibleRow; i <= lastVisibleRow; i++) {\n          // Skip persisted rows that overlap with visible cells.\n          while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i) {\n            persistIndex++;\n          }\n\n          res.push(node.children[i].layoutInfo);\n          this.addVisibleLayoutInfos(res, node.children[i], rect);\n        }\n\n        // Add persisted rows after the visible rows.\n        while (persistedRowIndices && persistIndex < persistedRowIndices.length) {\n          let idx = persistedRowIndices[persistIndex++];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n          }\n        }\n\n        // Always include loading sentinel even when virtualized, we assume it is always the last child for now\n        let lastRow = node.children.at(-1);\n        if (lastRow?.layoutInfo.type === 'loader') {\n          res.push(lastRow.layoutInfo);\n        }\n        break;\n      }\n      case 'headerrow':\n      case 'row': {\n        let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n        let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n        let stickyIndex = 0;\n\n        // Add persisted/sticky cells before the visible cells.\n        let persistedCellIndices = this.persistedIndices.get(node.layoutInfo.key) || this.stickyColumnIndices;\n        while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell) {\n          let idx = persistedCellIndices[stickyIndex];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n          }\n          stickyIndex++;\n        }\n\n        for (let i = firstVisibleCell; i <= lastVisibleCell; i++) {\n          // Skip sticky cells that overlap with visible cells.\n          while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i) {\n            stickyIndex++;\n          }\n\n          res.push(node.children[i].layoutInfo);\n        }\n\n        // Add any remaining sticky cells after the visible cells.\n        while (stickyIndex < persistedCellIndices.length) {\n          let idx = persistedCellIndices[stickyIndex++];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n          }\n        }\n        break;\n      }\n      default:\n        throw new Error('Unknown node type ' + node.layoutInfo.type);\n    }\n  }\n\n  private binarySearch(items: LayoutNode[], point: Point, axis: 'x' | 'y') {\n    let low = 0;\n    let high = items.length - 1;\n    while (low <= high) {\n      let mid = (low + high) >> 1;\n      let item = items[mid];\n\n      if ((axis === 'x' && item.layoutInfo.rect.maxX <= point.x) || (axis === 'y' && item.layoutInfo.rect.maxY <= point.y)) {\n        low = mid + 1;\n      } else if ((axis === 'x' && item.layoutInfo.rect.x > point.x) || (axis === 'y' && item.layoutInfo.rect.y > point.y)) {\n        high = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return Math.max(0, Math.min(items.length - 1, low));\n  }\n\n  private buildPersistedIndices() {\n    if (this.virtualizer!.persistedKeys === this.lastPersistedKeys) {\n      return;\n    }\n\n    this.lastPersistedKeys = this.virtualizer!.persistedKeys;\n    this.persistedIndices.clear();\n\n    // Build a map of parentKey => indices of children to persist.\n    for (let key of this.virtualizer!.persistedKeys) {\n      let layoutInfo = this.layoutNodes.get(key)?.layoutInfo;\n\n      // Walk up ancestors so parents are also persisted if children are.\n      while (layoutInfo && layoutInfo.parentKey) {\n        let collectionNode = this.virtualizer!.collection.getItem(layoutInfo.key);\n        let indices = this.persistedIndices.get(layoutInfo.parentKey);\n        if (!indices) {\n          // stickyColumnIndices are always persisted along with any cells from persistedKeys.\n          indices = collectionNode?.type === 'cell' || collectionNode?.type === 'column' ? [...this.stickyColumnIndices] : [];\n          this.persistedIndices.set(layoutInfo.parentKey, indices);\n        }\n\n        let index = this.layoutNodes.get(layoutInfo.key)?.index;\n        if (index != null && !indices.includes(index)) {\n          indices.push(index);\n        }\n\n        layoutInfo = this.layoutNodes.get(layoutInfo.parentKey)?.layoutInfo;\n      }\n    }\n\n    for (let indices of this.persistedIndices.values()) {\n      indices.sort((a, b) => a - b);\n    }\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget | null {\n    x += this.virtualizer!.visibleRect.x;\n    y += this.virtualizer!.visibleRect.y;\n\n    // Find the closest item within on either side of the point using the gap width.\n    let searchRect = new Rect(x, Math.max(0, y - this.gap), 1, Math.max(1, this.gap * 2));\n    let candidates = this.getVisibleLayoutInfos(searchRect);\n    let key: Key | null = null;\n    let minDistance = Infinity;\n    for (let candidate of candidates) {\n      // Ignore items outside the search rect, e.g. persisted keys.\n      if (candidate.type !== 'row' || !candidate.rect.intersects(searchRect)) {\n        continue;\n      }\n\n      let yDist = Math.abs(candidate.rect.y - y);\n      let maxYDist = Math.abs(candidate.rect.maxY - y);\n      let dist = Math.min(yDist, maxYDist);\n      if (dist < minDistance) {\n        minDistance = dist;\n        key = candidate.key;\n      }\n    }\n\n    if (key == null || this.virtualizer!.collection.size === 0) {\n      return {type: 'root'};\n    }\n\n    let layoutInfo = this.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return null;\n    }\n\n    let rect = layoutInfo.rect;\n    let target: DropTarget = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    } else if (y <= rect.y + 10 && isValidDropTarget({...target, dropPosition: 'before'})) {\n      target.dropPosition = 'before';\n    } else if (y >= rect.maxY - 10 && isValidDropTarget({...target, dropPosition: 'after'})) {\n      target.dropPosition = 'after';\n    }\n\n    return target;\n  }\n\n  getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo {\n    let layoutInfo = super.getDropTargetLayoutInfo(target);\n    layoutInfo.parentKey = (this.virtualizer!.collection as TableCollection<T>).body.key;\n    return layoutInfo;\n  }\n}\n"],"names":[],"version":3,"file":"TableLayout.module.js.map"}